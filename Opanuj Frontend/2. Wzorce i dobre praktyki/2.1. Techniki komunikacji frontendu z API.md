

## **Wprowadzenie**

Poprzednie dwie lekcje pokazaÅ‚y ci, jak szerokim zagadnieniem jest zarzÄ…dzanie stanem aplikacji. OpanowaÅ‚eÅ› stan lokalny i globalny, wiÄ™c zabierasz siÄ™ do jego inicjalizacji. Tylko skÄ…d go pobraÄ‡?

Nowoczesne narzÄ™dzia takie jak [Vite](https://vitejs.dev/) czy [Parcel](https://parceljs.org/) umoÅ¼liwiajÄ… ci importy plikÃ³w, moÅ¼esz wykorzystaÄ‡ Web Storage API (Local Storage i Session Storage), a nawet pobieraÄ‡ stan z poziomu parametrÃ³w URL czy informacji w cookies.

Przede wszystkim moÅ¼esz jednak zdecydowaÄ‡ siÄ™ na utrzymywanie i aktualizowanie stanu aplikacji po stronie serwera. To wÅ‚aÅ›nie tam najczÄ™Å›ciej przechowywane jest ÅºrÃ³dÅ‚o prawdy o wszystkim, co dzieje siÄ™ w ramach aplikacji. Serwer to absolutnie fundamentalna skÅ‚adowa aplikacji webowych, ktÃ³re dziaÅ‚ajÄ…c w modelu _â€œclient-serverâ€_ rozdzielajÄ… pomiÄ™dzy dwie warstwy poszczegÃ³lne odpowiedzialnoÅ›ci.

Serwer to w duÅ¼ym uproszczeniu niezaleÅ¼nie dziaÅ‚ajÄ…cy komputer, z ktÃ³rym prÃ³bujemy siÄ™Â komunikowaÄ‡ przez wystawiony publicznie interfejs (API). Aby robiÄ‡ to skutecznie, w tej lekcji:

- Poznasz terminologiÄ™ i najwaÅ¼niejsze koncepty komunikacji z API na backendzie
    
- Poznasz popularne narzÄ™dzia sÅ‚uÅ¼Ä…ce do pobierania i aktualizowania danych
    
- Poznasz dobre praktyki w budowaniu wielowarstwowej aplikacji dostÄ™pnej 24/7
    

Zaczynajmy!

## API, ale jakie?

Sam akronim API (Application Programming Interface) nie mÃ³wi wprost, z jakiego rodzaju interfejsem pracujemy. Zazwyczaj dotyczy jednak pewnej â€œbramkiâ€ przez ktÃ³rÄ… uzyskujemy dostÄ™p do zestawu okreÅ›lonych zasobÃ³w. Czasami tym terminem okreÅ›la siÄ™ zbiÃ³r publicznie dostÄ™pnych funkcji w bibliotece lub frameworku, czasami mÃ³wimy o publicznej czÄ™Å›ci jednego z wielu moduÅ‚Ã³w tej samej aplikacji, a czasami o REST / GraphQL API.

Dla uproszczenia ustalmy, Å¼e w tej lekcji wymiennie bÄ™dziemy siÄ™ posÅ‚ugiwaÄ‡ takimi terminami jak serwer, API lub backend.

W kaÅ¼dym z tych przypadkÃ³w mamy na myÅ›li pewnego rodzaju ==**zasÃ³b zdalny, dziaÅ‚ajÄ…cy poza granicami przeglÄ…darki, z ktÃ³rym interakcja odbywa siÄ™ asynchronicznie**==, w modelu klient-serwer. Na poczÄ…tku skupimy siÄ™ na ==***modelu pull***==, w ktÃ³rym frontend pobiera na Å¼Ä…danie dane z backendu, ale na koÅ„cu omÃ³wimy takÅ¼e ==**_model push_**==, w ktÃ³rym to serwer decyduje o momencie publikacji informacji do klientÃ³w (WebSockets).

## API w aplikacjach webowych

Najbardziej popularne podejÅ›cia do budowania webowych API oparte sÄ… o REST oraz GraphQL.

### REST API

==**To styl architektury**, ktÃ³ry promuje udostÄ™pnianie zasobÃ³w wykorzystujÄ…c metody HTTP, takie jak GET, POST, PUT czy DELETE. Metody te stosuje siÄ™ do nastÄ™pujÄ…cych operacji==:

- **GET** - pobieranie listy zasobÃ³w lub jednego zasobu o okreÅ›lonym identyfikatorze, bez modyfikowania jego stanu
- **HEAD** - sprawdzenie nagÅ‚Ã³wkÃ³w, jakie zostaÅ‚yby nadane stosujÄ…c metodÄ™ GET (moÅ¼e sÅ‚uÅ¼yÄ‡ do wstÄ™pnej analizy rozmiaru i dostÄ™pnoÅ›ci pobieranego zasobu)
- **POST** - dodawanie nowego zasobu
- **PUT** - aktualizowanie zasobu o okreÅ›lonym identyfikatorze
- **PATCH** - czÄ™Å›ciowa aktualizacja zasobu o okreÅ›lonym identyfikatorze (np. z uÅ¼yciem [JSON Patch](https://jsonpatch.com/))
- **DELETE** - usuwanie zasobu o okreÅ›lonym identyfikatorze
- **OPTIONS** - sprawdzenie dostÄ™pnych metod HTTP dla klienta (w przypadku zapytaÅ„ [cross-origin](https://auth0.com/blog/cors-tutorial-a-guide-to-cross-origin-resource-sharing/))
    

==KaÅ¼de Å¼Ä…danie HTTP w architekturze REST jest **bezstanowe**, co oznacza, Å¼e serwer nie przechowuje Å¼adnych informacji o stanie klienta== (aplikacji webowej, aplikacji mobilnej, etc.). Zasoby mogÄ… byÄ‡ reprezentowane w rÃ³Å¼nych formatach, takich jak JSON (na dzisiaj to najbardziej popularny format udostÄ™pniania danych), XML czy HTML. Klient i serwer negocjujÄ… format reprezentacji za pomocÄ… nagÅ‚Ã³wkÃ³w HTTP.

PracujÄ…c na frontendzie z klasycznym REST API, nasze zapytania mogÄ… wyglÄ…daÄ‡ w ten sposÃ³b:

```txt
GET /users           # pobranie listy uÅ¼ytkownikÃ³w
GET /users/:id       # pobranie uÅ¼ytkownika o konkretnym id
POST /users          # utworzenie nowego uÅ¼ytkownika
PUT /users/:id       # zaktualizowanie danych uÅ¼ytkownika o konkretnym id
DELETE /users/:id    # usuniÄ™cie uÅ¼ytkownika o konkretnym id
```

W praktyce zdarza siÄ™, Å¼e od tak â€œksiÄ…Å¼kowoâ€ zaprojektowanego API zdarzajÄ… siÄ™ odstÄ™pstwa. SzczegÃ³lnie w warstwie Backend-For-Frontend (o ktÃ³rej w dalszych lekcjach) znajdziemy bardziej zÅ‚oÅ¼one API udostÄ™pniajÄ…ce wiele zasobÃ³w jednoczeÅ›nie, albo wystawiajÄ…ce dane pod konkretny fragment interfejsu aplikacji.

WiÄ™cej na ten temat przeczytasz we wpisie - [Data API vs Application API](https://max.engineer/server-informed-ui)

### RÃ³Å¼nice pomiÄ™dzy metodami

Pytaniem, ktÃ³re w kontekÅ›cie REST API czÄ™sto pojawia siÄ™ na rozmowach kwalifikacyjnych, jest to o rÃ³Å¼nicÄ™ pomiÄ™dzy zapytaniami POST, PUT i PATCH (GET i DELETE sÄ… Å‚atwe w odszyfrowaniu).

==Dobra odpowiedÅº powinna zawieraÄ‡ wzmiankÄ™ o tym, Å¼e **PUT** jest **idempotentny**. Oznacza to, Å¼e wielokrotne wysyÅ‚anie tego samego Å¼Ä…dania jest bezpieczne i powtarzalne (np. typowy scenariusz - aktualizacja danych)==.

**POST/PATCH nie jest idempotentny -** wysyÅ‚ajÄ…c taki sam zestaw parametrÃ³w kilka razy, moÅ¼emy siÄ™ spodziewaÄ‡ skutkÃ³w ubocznych (np. bÅ‚Ä™dÃ³w pt. â€œuÅ¼ytkownik z tym adresem email juÅ¼ istniejeâ€).

PrzyjÄ™Å‚o siÄ™, Å¼e:

- **PUT** stosujemy w przypadku bezpiecznej aktualizacji caÅ‚oÅ›ci istniejÄ…cych zasobÃ³w
- **PATCH** stosujemy w przypadku aktualizacji fragmentÃ³w istniejÄ…cych zasobÃ³w (np. kilka pÃ³l)
- **POST** stosujemy w przypadku tworzenia nowych zasobÃ³w

### Publiczne API

W sieci znajdziesz mnÃ³stwo publicznych API, na ktÃ³rych moÅ¼esz Ä‡wiczyÄ‡ kolejne aspekty budowania aplikacji webowych, korzystajÄ…cych z zewnÄ™trznych zasobÃ³w.

Popularna lista znajduje siÄ™ pod tym adresem - [https://github.com/public-apis/public-apis](https://github.com/public-apis/public-apis)

### Fragmenty zapytania HTTP

W kontekÅ›cie zapytaÅ„ HTTP, okreÅ›lenie samej metody zapytania nie wystarczy. JeÅ›li chcemy przekazywaÄ‡ dane pomiÄ™dzy klientem i serwerem, powinniÅ›my rozumieÄ‡ czym rÃ³Å¼niÄ… siÄ™ **body** i **query string**, a takÅ¼e kiedy potrzebne nam bÄ™dÄ… **nagÅ‚Ã³wki (headers)**.

- **Body** (ciaÅ‚o) Å¼Ä…dania HTTP to czÄ™Å›Ä‡ wiadomoÅ›ci, ktÃ³ra zawiera ==dane wysyÅ‚ane do serwera==. Jest uÅ¼ywane gÅ‚Ã³wnie w metodach **POST, PUT, PATCH**, gdzie dane sÄ… czÄ™Å›ciÄ… treÅ›ci Å¼Ä…dania. MoÅ¼e zawieraÄ‡ rÃ³Å¼ne rodzaje danych, takie jak dane formularza, JSON, XML, pliki binarne itp. Jest uÅ¼ywane do przesyÅ‚ania wiÄ™kszej iloÅ›ci danych, ktÃ³re sÄ… czÄ™sto wymagane w operacjach takich jak tworzenie lub aktualizacja zasobu (np. tworzenie nowego uÅ¼ytkownika z danymi uÅ¼ytkownika w formacie JSON).
- **Query string** to czÄ™Å›Ä‡ URL, ktÃ³ra zawiera parametry zapytania, ktÃ³re mogÄ… byÄ‡ uÅ¼ywane do przekazania dodatkowych informacji do serwera. Rozpoczyna siÄ™ od znaku zapytania **?** i zawiera pary klucz-wartoÅ›Ä‡ oddzielone znakiem **&**. SkÅ‚ada siÄ™ z prostych par klucz-wartoÅ›Ä‡, gdzie klucz i wartoÅ›Ä‡ sÄ… ciÄ…gami znakÃ³w. Jest powszechnie uÅ¼ywany w Å¼Ä…daniach **GET,** aby przekazaÄ‡ krÃ³tkie dane do serwera, takie jak parametry wyszukiwania, filtrÃ³w, numerowania stron czy kampanii reklamowych.
- **Headers**, czyli nagÅ‚Ã³wki, to dodatkowy sposÃ³b na przekazywanie metadanych pomiÄ™dzy klientem i serwerem. NagÅ‚Ã³wki pomagajÄ… okreÅ›liÄ‡ sposÃ³b przetwarzania Å¼Ä…dania lub odpowiedzi. SpoÅ›rÃ³d tych najczÄ™Å›ciej wykorzystywanych warto znaÄ‡ ===**Content-Type** (typ przekazywanych danych), **Authorization** (metadane uwierzytelniania zapytania) oraz **Accept** (oczekiwany typ odpowiedzi)===.
    
### Obietnica lepszego REST API - GraphQL

To technologia opublikowana przez Facebooka w 2015r., ktÃ³ra w zaÅ‚oÅ¼eniu miaÅ‚a rozwiÄ…zywaÄ‡ problem rozproszonych REST API w duÅ¼ej skali. DziÄ™ki [GraphQL](https://graphql.org/) autorzy aplikacji client-side (najczÄ™Å›ciej aplikacji webowych i mobilnych) nie muszÄ… wykonywaÄ‡ izolowanych zapytaÅ„ po poszczegÃ³lne zasoby, a nastÄ™pnie Å‚Ä…czyÄ‡ je pole po polu, ale mogÄ… wysÅ‚aÄ‡ jedno zapytanie do rozwiÄ…zania przez serwer GraphQL.

Zapytania do API opartego o GraphQL najczÄ™Å›ciej wykorzystujÄ… dwie metody HTTP - POST i GET, jednak ich zasoby nie sÄ… udostÄ™pniane przez wiele rÃ³Å¼nych endpointÃ³w, a jeden gÅ‚Ã³wny. Co decyduje o ksztaÅ‚cie zwracanych danych? Samo zapytanie, ktÃ³rego **body** (lub rzadziej - query string) okreÅ›la pola ktÃ³rych potrzebujemy, lub planujemy modyfikowaÄ‡:

```graphql

query UserWithComments {
  user {
    name
    comments {
      body
    }
  }
}
```

PowyÅ¼sze zapytanie zostaje rozwiÄ…zane w oparciu o zasoby **User** i **Comments**, a w odpowiedzi uzyskujemy:

```javascript
{
  "data": {
    "user": {
      "name": "John Doe",
      "comments": [
        {
          "body": "Great job!"
        },
        {
          "body": "Amazing!"
        },
        {
          "body": "I love it!"
        }
      ]
    }
  }
}
```

GÅ‚Ã³wnÄ… zaletÄ… GraphQL jest Å‚Ä…czenie wielu zapytaÅ„ do API w jedno, co moÅ¼e byÄ‡ istotnÄ… kwestiÄ… w przypadku klientÃ³w o mniejszych zasobach sprzÄ™towych, oraz zaletÄ… dla programistÃ³w frontend, ktÃ³rzy oczekujÄ… wiÄ™kszej elastycznoÅ›ci w pracy. ==IstotnÄ… wadÄ…, ktÃ³ra powoduje Å¼e na GraphQL nie decyduje siÄ™ wiÄ™kszoÅ›Ä‡ maÅ‚ych i Å›rednich firm, jest narzut zwiÄ…zany z utrzymaniem dodatkowej infrastruktury==. WdraÅ¼ajÄ…c GraphQL, w stosie technologicznym danego rozwiÄ…zania musimy dodaÄ‡ kolejnÄ… warstwÄ™, ktÃ³ra poÅ‚Ä…czy zapytania od klientÃ³w z rozproszonymi, niezaleÅ¼nymi API.

JeÅ›li chcesz sprawdziÄ‡ jak pracuje siÄ™ z tego typu interfejsem, moÅ¼esz wykorzystaÄ‡ jedno z publicznie dostÄ™pnych API, np.:

- Countries API - [https://github.com/trevorblades/countries](https://github.com/trevorblades/countries)
- Anime List API - [https://anilist.gitbook.io/anilist-apiv2-docs/](https://anilist.gitbook.io/anilist-apiv2-docs/)
- GitHub GraphQL API - [https://docs.github.com/en/graphql](https://docs.github.com/en/graphql)

W tym miejscu znajdziesz zestaw starannie redagowanych zasobÃ³w na temat GraphQL - [Awesome GraphQL](https://github.com/chentsulin/awesome-graphql).

## Komunikacja z API na poziomie aplikacji

### Fetch API

NiezaleÅ¼nie od stosowanego frameworka, najbardziej standardowym podejÅ›ciem do wykonywania zapytaÅ„ HTTP w aplikacjach frontendowych jest obecnie Fetch API. To zamiennik dla starszego API XMLHttpRequest (XHR). Metoda `fetch`, czyli gÅ‚Ã³wny skÅ‚adnik Fetch API, opiera siÄ™ o Promise, co znacznie uÅ‚atwia obsÅ‚ugÄ™ asynchronicznych zapytaÅ„ a takÅ¼e obsÅ‚ugÄ™ rezultatÃ³w danego zapytania.

Oto prosty przykÅ‚ad pokazujÄ…cy, jak uÅ¼ywaÄ‡ Fetch API do wykonania Å¼Ä…dania GET (bez peÅ‚nej obsÅ‚ugi bÅ‚Ä™dÃ³w, o czym poniÅ¼ej):

```javascript
fetch('/api/users.json')
  .then(response => response.json()) // Parsowanie odpowiedzi jako JSON
  .then(data => console.log(data)) // Przetwarzanie otrzymanych danych
  .catch(error => console.error('Fetching error:', error));
```

Wykonanie Å¼Ä…dania POST z konkretnymi parametrami wymaga dodatkowego obiektu konfiguracyjnego:

```javascript
// Konfiguracja Å¼Ä…dania
const requestOptions = {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data) // Serializacja danych do formatu JSON
};

// Wykonanie Å¼Ä…dania POST
fetch('/api/users.json', requestOptions)
  .then(response => response.json()) // Parsowanie odpowiedzi jako JSON
  .then(data => console.log(data)) // Przetwarzanie otrzymanych danych
  .catch(error => console.error('Fetching error:', error));
```

Fetch API moÅ¼emy teÅ¼ z powodzeniem Å‚Ä…czyÄ‡Â z async/await:

```javascript
async function fetchData(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Fetching error:', error);
  }
}

fetchData('/api/users.json');
```

Strona [CanIUse](https://caniuse.com/fetch) podaje, Å¼e to natywne rozwiÄ…zanie moÅ¼emy juÅ¼ stosowaÄ‡ w niemal wszystkich nowoczesnych przeglÄ…darkach internetowych:

### Fetch API - ObsÅ‚uga bÅ‚Ä™dÃ³w

W przeciwieÅ„stwie do innych popularnych bibliotek HTTP, takich jak omawiany poniÅ¼ej Axios, Fetch API **nie odrzuca** automatycznie tych zapytaÅ„, ktÃ³re koÅ„czÄ… siÄ™ serwerowymi kodami z zakresu 4xx i 5xx. Oznacza to, Å¼e odpowiedzi pokroju â€œNot Foundâ€ i â€œServer Errorâ€ sÄ… traktowane jako zakoÅ„czone sukcesem, co moÅ¼e byÄ‡ mylÄ…ce i prowadziÄ‡ do problemÃ³w.

==Koniecznie zapamiÄ™taj, Å¼e otrzymanie kodu innego niÅ¼Â 2xx nie jest jednoznaczne z odrzuceniem Promiseâ€™a przez Fetch API==:

```javascript
fetch('/api/users.json')
  .then(response => {
    return response.json(); // JeÅ›li otrzymasz kod 4xx lub 5xx, ten fragment i tak siÄ™ wykona
  })
  .then(data => {
    console.log('Data:', data);
  })
  .catch(error => { // Klasyczny "catch" nie wystarczy do peÅ‚nej obsÅ‚ugi bÅ‚Ä™dÃ³w
    console.error('BÅ‚Ä…d:', error); 
  });
```

Oto przykÅ‚ad, ktÃ³ry ilustruje, jak Fetch API radzi sobie z odpowiedziami 4xx i 5xx, oraz jak moÅ¼esz prawidÅ‚owo obsÅ‚uÅ¼yÄ‡ te przypadki:

```javascript
fetch('/api/users.json')
  .then(response => {
    if (!response.ok) { // Promise rozwiÄ…zany z sukcesem, ale pole "ok" jest ustawione na false
      // JeÅ›li status odpowiedzi nie jest w zakresie 2xx, wyrzuÄ‡ bÅ‚Ä…d
      throw new Error(`HTTP Error: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    console.log('Data:', data);
  })
  .catch(error => {
    console.error('BÅ‚Ä…d:', error);
  });
```

Fetch API to ogromny krok naprzÃ³d w porÃ³wnaniu do zapytaÅ„ realizowanych przez obiekt XMLHttpRequest, ale byÄ‡ moÅ¼e oczekujesz jeszcze wiÄ™kszego komfortu pracy z API. W takim przypadku jednÄ… z najbardziej popularnych opcji jest biblioteka **axios**.

### Axios

[Axios](https://axios-http.com/) jest popularnÄ… bibliotekÄ… JavaScript do wykonywania zapytaÅ„ HTTP, uÅ¼ywanÄ… zarÃ³wno w aplikacjach przeglÄ…darkowych, jak i Node.js. Jest to alternatywa dla natywnej metody **fetch**.

Jej gÅ‚Ã³wne zalety to:

- **automatyczne przeksztaÅ‚canie danych na format JSON**
    - w Fetch API musimy to zrobiÄ‡ sami
- **==interceptory**, czyli opakowywanie zapytaÅ„ i odpowiedzi z serwera==
    - w Fetch API wymaga to rÄ™cznej implementacji
- **intuicyjna obsÅ‚uga bÅ‚Ä™dÃ³w (w oparciu o kody niÅ¼ inne 2xx)**
    - w Fetch API kody takie jak 4xx i 5xx sÄ… uznawane za sukces (otrzymanie odpowiedzi)
- **rozbudowane wsparcie dla anulowania i limitÃ³w czasowych zapytaÅ„**
    - przez dodatkowy parametr (timeout na poziomie oczekiwania na odpowiedÅº)
    - ==z wykorzystaniem **AbortControlle**r (timeout na poziomie nawiÄ…zywania poÅ‚Ä…czenia)==
- wsparcie dla starszych przeglÄ…darek
    

Wykonanie podstawowego zapytania GET w bibliotece **axios** wyglÄ…da doÅ›Ä‡ podobnie do Fetch API:

```javascript
import axios from 'axios';

axios.get('/api/users.json')
  .then(response => {
    console.log(response.data); // dane sÄ… juÅ¼ sparsowane jako JSON
  })
  .catch(error => {
    console.error('Error fetching data:', error);
  });
```

Natomiast w przypadku POST nie musimy rÄ™cznie konwertowaÄ‡ obiektu na JSON:

```javascript
import axios from 'axios';

axios.post('/api/users', {
  firstName: 'Fred',
  lastName: 'Flintstone'
})
.then(function (response) {
  console.log(response);
})
.catch(function (error) {
  console.log(error);
});
```

WiÄ™cej rÃ³Å¼nic zauwaÅ¼ymy budujÄ…c obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w i wsparcie dla przekroczenia czasu oczekiwania na odpowiedÅº.

### Axios vs Fetch API - Brak odpowiedzi z serwera

PracujÄ…c z aplikacjami webowymi na produkcji, musimy siÄ™ przygotowaÄ‡ na nieprzewidziane sytuacje na styku frontendu i backendu. JednÄ… z takich sytuacji jest przekroczenie czasu odpowiedzi z serwera. MoÅ¼e to byÄ‡ spowodowane wysokim obciÄ…Å¼eniem serwera, wykonaniem nieoptymalnego zapytania do bazy, czy niedostÄ™pnoÅ›ci innego serwisu, z ktÃ³rym nasz backend jest powiÄ…zany.

Aby zapewniÄ‡Â optymalne doÅ›wiadczenia dla uÅ¼ytkownika, nasz frontend powinien mieÄ‡ zdefiniowany maksymalny czas oczekiwania na odpowiedÅº i poprawnie obsÅ‚ugiwaÄ‡ takÄ… sytuacjÄ™.

PorÃ³wnajmy oba rozwiÄ…zania. Najpierw Fetch API i Promise.race:

```javascript
// Rozbudowanie Fetch API o obsÅ‚ugÄ™ maksymalnego czasu oczekiwania
const fetchWithTimeout = (url, timeout) => {
  return Promise.race([
    fetch(url),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), timeout)
    )
  ]);
};

fetchWithTimeout('/api/users.json', 5000) // timeout 5 sekund
  .then(response => /* obsÅ‚uga odpowiedzi */)
  .catch(error => /* obsÅ‚uga bÅ‚Ä™du lub timeoutu */);
```

W powyÅ¼szym przykÅ‚adzie **Promise.race** oczekuje na pierwszy Promise, ktÃ³ry zostanie rozwiÄ…zany. JeÅ›li uzyskamy odpowiedÅº na zapytanie HTTP poniÅ¼ej czasu w parametrze _timeout_, to zostanie ona zwrÃ³cona. JeÅ›li nie, to otrzymamy odrzucony Promise z wiadomoÅ›ciÄ… â€˜Timeoutâ€™.

W axios wyglÄ…da to zdecydowanie mniej skomplikowanie, a logika timeoutu ukryta jest w bibliotece:

```javascript
import axios from 'axios';

// Natywne wsparcie dla parametru timeout w axios
axios.get('/api/users.json', { timeout: 5000 }) // timeout 5 sekund
  .then(response => /* obsÅ‚uga odpowiedzi */)
  .catch(error => {
    if (error.code === 'ECONNABORTED') {
      console.log('Timeout');
    } else {
      /* obsÅ‚uga innych bÅ‚Ä™dÃ³w */
    }
  });
```

Biblioteka wspiera rÃ³wnieÅ¼ globalnÄ… konfiguracjÄ™, ktÃ³rej moÅ¼emy uÅ¼ywaÄ‡ na przekroju caÅ‚ej aplikacji:

```javascript
import axios from 'axios';

export const myProductApi = axios.create({
  baseURL: 'https://myproduct.com',
  timeout: 5000
});

const users = await myProductApi.get('/users') // timeout: 5s
const items = await myProductApi.get('/items') // timeout: 5s
```

### Axios - Anulowanie Å¼Ä…dania przez klienta

Poza przekroczeniem czasu na odpowiedÅº, drugim ze scenariuszy zwiÄ…zanych z obsÅ‚ugÄ… bÅ‚Ä™dÃ³w jest przekroczenie czasu nawiÄ…zywania poÅ‚Ä…czenia z serwerem, lub anulowanie zapytania na skutek konkretnej akcji uÅ¼ytkownika.

PrzykÅ‚adowo, kiedy budujemy duÅ¼Ä… aplikacjÄ™ do wyszukiwania danych, uÅ¼ytkownik moÅ¼e zmieniaÄ‡Â zakres filtrÃ³w zanim jeszcze otrzyma odpowiedÅº na poprzednie zapytanie. Bez anulowania zapytaÅ„ interfejs uÅ¼ytkownika moÅ¼e siÄ™ zmieniaÄ‡ zbyt wiele razy.

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module1/lesson4/abort-controller_**.

Aby lepiej zarzÄ…dzaÄ‡ rÃ³wnolegÅ‚ymi i juÅ¼Â trwajÄ…cymi zapytaniami, moÅ¼emy wykorzystaÄ‡Â wbudowany w przeglÄ…darkÄ™ AbortController (ktÃ³rego wsparcie przewiduje rÃ³wnieÅ¼ Fetch API).

```javascript
import axios from 'axios';

const controller = new AbortController(); // AbortController to obiekt wbudowany w przeglÄ…darkÄ™

axios.get('/api/users.json', {
   signal: controller.signal
}).then((response) => {
   //...
}).catch((error) => {
  if (!axios.isCancel(error)) {
    // ObsÅ‚uga bÅ‚Ä™du innego niÅ¼ rÄ™czne anulowanie zapytania
  }
})

controller.abort() // WywoÅ‚anie funkcji abort spowoduje anulowanie zapytania
```

To od ciebie zaleÅ¼y kto i kiedy bÄ™dzie mÃ³gÅ‚ wywoÅ‚aÄ‡ funkcje â€œabortâ€. MoÅ¼e to byÄ‡ gÅ‚Ä™boki fragment aplikacji, albo rozbudowanie jednej z funkcji wywoÅ‚ywanej przez uÅ¼ytkownika.

Na koÅ„cu lekcji znajdziesz Ä‡wiczenie, w ktÃ³rym przetestujesz posÅ‚ugiwanie siÄ™ AbortControllerem.

### Axios - Interceptory (Wzorzec Dekorator)

KorzystajÄ…c z axiosa warto zainteresowaÄ‡ siÄ™ wykorzystaniem tzw. InterceptorÃ³w, czyli klasycznego przypadku uÅ¼ycia wzorca projektowego **Dekorator**.

Czym jest Dekorator? Dekorator to wzorzec, ktÃ³ry przydaje siÄ™ kiedy udostÄ™pniamy konsumentowi konkretny, zamkniÄ™ty zestaw funkcjonalnoÅ›ci (np. zestaw funkcji do zapytaÅ„ HTTP), ale chcemy rÃ³wnieÅ¼ umoÅ¼liwiÄ‡ jej rozszerzanie, np. dodanie logowania do kaÅ¼dego zapytania. OsiÄ…gniemy to wÅ‚aÅ›nie dziÄ™ki wzorcowi Dekorator, ktÃ³ry na konkretnym przykÅ‚adzie w bibliotece axios wyglÄ…da w ten sposÃ³b:

```javascript
import axios from 'axios';

const requestLogger = (config) => {
  console.log(
    `Zapytanie ${config.method} pod ${config.url} zarejestrowano o ${new Date().toISOString()}`
  );
  return config;
}

axios.interceptors.request.use(requestLogger);

const { data: { users }} = await axios.get('/api/users.json')
const { data: { items }} = await axios.get('/api/items.json')
```

DziÄ™ki dodaniu interceptora `requestLogger` do wychodzÄ…cych zapytaÅ„, po wykonaniu dwÃ³ch Å¼Ä…daÅ„ GET w konsoli pojawiajÄ… siÄ™Â dwa wpisy:

```text
Zapytanie get pod /api/users.json zarejestrowano o 2024-02-01T08:58:26.550Z
Zapytanie get pod /api/items.json zarejestrowano o 2024-02-01T08:58:26.556Z
```

NiezaleÅ¼nie od zapytaÅ„ moÅ¼emy teÅ¼ rozszerzaÄ‡ procesowanie odpowiedzi. W obu przypadkach do wykorzystania mamy dwa parametry funkcji â€œuseâ€ - pierwszy to interceptor odpowiedzi z kodem 2xx, czyli sukcesu, a drugi to obsÅ‚uga bÅ‚Ä™dÃ³w:

```javascript
axios.interceptors.response.use(successInterceptor, errorInterceptor);
```

PotencjaÅ‚ interceptorÃ³w jest naprawdÄ™ szeroki - moÅ¼e to byÄ‡ logowanie zapytaÅ„, obsÅ‚uga i analiza bÅ‚Ä™dÃ³w, albo nawet zarzÄ…dzanie konkretnymi fragmentami interfejsu, prezentujÄ…cymi stan oczekiwania na odpowiedÅº z serwera.

W duÅ¼ej skali interceptory sÄ… szczegÃ³lnie przydatne wtedy, kiedy konwencjÄ… w firmie nie jest poleganie na surowej wersji biblioteki. Zamiast tego, zespÃ³Å‚ platformowy moÅ¼e przygotowaÄ‡ â€œaxiosa++â€ i udostÄ™pniÄ‡ go w wewnÄ™trznym repozytorium rozbudowujÄ…c go wÅ‚aÅ›nie przez interceptory.

### Modyfikowanie klientÃ³w HTTP (Wzorzec Proxy)

Obiekty takie jak **fetch** i **axios** czÄ™sto nazywa siÄ™Â **klientami HTTP**. ZawierajÄ… one metody niezbÄ™dne do wykonywania zapytaÅ„, a takÅ¼e wczeÅ›niej przygotowanÄ… konfiguracjÄ™ adresÃ³w docelowych serwisÃ³w, nagÅ‚Ã³wkÃ³w czy obsÅ‚ugi bÅ‚Ä™dÃ³w.

Zdarza siÄ™, Å¼e rozbudowywane konfiguracje klientÃ³w HTTP sÄ… ukrywane w dedykowanych moduÅ‚ach, a programiÅ›ci nie pracujÄ… z surowÄ… wersjÄ… biblioteki, a wÅ‚aÅ›nie z wersjÄ… rozszerzonÄ…. Jak takie rozszerzenie przygotowaÄ‡? Jednym z wczeÅ›niej zaprezentowanych rozwiÄ…zaÅ„ sÄ… interceptory, ale moÅ¼na do tego celu wykorzystaÄ‡ takÅ¼e wbudowany obiekt **Proxy.**

Jak dziaÅ‚a Proxy? StwÃ³rzmy prostÄ… klasÄ™Â i jej rozszerzenie przez Proxy:

```javascript
class User {
  constructor(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }
}

// Funkcja korzystajÄ…ca z Proxy do rozszerzenia moÅ¼liwoÅ›ci obiektÃ³w klasy User
function createUserProxy(user) {
  return new Proxy(user, {
    get(target, property, receiver) {
      if (property === 'getName') {
        return () => `User Name: ${target.getName()}`;
      }
      return property;
    }
  });
}
```

W tym przykÅ‚adzie, tworzymy funkcjÄ™ **createUserProxy**, ktÃ³ra tworzy **Proxy** dla instancji **User**. Gdy odwoÅ‚ujemy siÄ™ do metody **getName**, **Proxy** modyfikuje jej dziaÅ‚anie, dodajÄ…c prefix â€œUser Name:â€¦â€.

Wzorzec (i obiekt) Proxy to jedna z wielu moÅ¼liwoÅ›ci rozszerzania zachowania obiektÃ³w, bez ingerowania w ich detale implementacyjne:

```javascript
const user = new User('Marek');
console.log(user.getName()); // Marek

const proxiedUser = createUserProxy(user);
console.log(proxiedUser.getName()); // User Name: Marek
```

To samo Proxy moÅ¼emy wykorzystaÄ‡ do rozbudowywania naszych klientÃ³w, dodajÄ…c do zapytaÅ„ nowe nagÅ‚Ã³wki (wg konwencji - z prefixem â€œx-â€) czy parametry konfiguracji:

```javascript
import { v4 as uuidv4 } from 'uuid';

const fetchProxy = new Proxy(fetch, {
  apply(target, thisArg, argumentsList) {
    let [url, cfg] = argumentsList;
    const newHeader = { 'x-req-id': `kurs-${uuidv4()}` };
    return target(url, {
      ...cfg,
      headers: {
        ...cfg?.headers,
        ...newHeader,
      },
    });
  },
});

fetchProxy('/api/users.json')
  .then((response) => response.json())
  .then((data) => console.log(data));
```

KorzystajÄ…c z **fetchProxy**, nasze zapytania bÄ™dÄ… wzbogacone o nowy nagÅ‚Ã³wek, ktÃ³ry moÅ¼emy czytaÄ‡ na backendzie, a o ktÃ³rym frontend developer nie musi pamiÄ™taÄ‡:

Co waÅ¼ne, w takim podejÅ›ciu nie modyfikujemy wbudowanego w przeglÄ…darkÄ™ obiektu **fetch** (bardzo zÅ‚a praktyka, niestety wciÄ…Å¼ spotykana na frontendzie), ale uzyskujemy jego alternatywnÄ… wersjÄ™.

## Zapytania HTTP w popularnych frameworkach

Opisywane wczeÅ›niej Fetch API jak i bibliotekÄ™ axios moÅ¼esz z powodzeniem wykorzystywaÄ‡ w kaÅ¼dym nowoczesnym frameworku frontendowym. W szczegÃ³Å‚ach skupimy siÄ™ na tej tematyce w kolejnej lekcji, natomiast poniÅ¼ej krÃ³tko podsumowujemy jak wyglÄ…da obecnie sytuacja z zapytaniami HTTP w danym ekosystemie:

### React / Vue / Svelte

Å»aden z tych frameworkÃ³w nie wymusza, ani nie dostarcza konkretnego klienta HTTP. Jest to zgodne z filozofiÄ…Â tych technologii, skupiajÄ…cych siÄ™ przede wszystkim na rozwijaniu interaktywnych, reaktywnych widokÃ³w.

Zwykle w ich przypadku uÅ¼ywa siÄ™ bezpoÅ›rednio metod Fetch API, bibliotek zewnÄ™trznych jak Axios, [TanStack Query](https://tanstack.com/query/latest/) i dodatkÃ³w takich jak [swr](https://swr.vercel.app/) lub bardziej [rozbudowanych hookÃ³w](https://react.dev/learn/synchronizing-with-effects).

RÃ³Å¼nice mogÄ… siÄ™ pojawiÄ‡ na poziomie obsÅ‚ugi stanu, Å›ledzenia zmian i optymalizowania pracy komponentÃ³w, ale na tym wÅ‚aÅ›nie skupimy siÄ™ w kolejnej lekcji.

### Angular

Angular promuje filozofiÄ™ â€œbatteries includedâ€, dostarczajÄ…c programistom serwis **HttpClient**, ktÃ³rym zrealizujemy zapytania do API z poziomu naszej aplikacji.

**HttpClient** jest Å›ciÅ›le zintegrowany z bibliotekÄ… RxJS, co oznacza, Å¼e operacje HTTP zwracajÄ… obiekty typu Observable sÅ‚uÅ¼Ä…ce do obsÅ‚ugi asynchronicznych strumieni danych. Pozwala to na Å‚atwe stosowanie operatorÃ³w RxJS do transformacji, filtrowania i Å‚Ä…czenia zapytaÅ„ HTTP z innymi typami zdarzeÅ„. Wbudowany klient HTTP jest projektowany z myÅ›lÄ… o integracji z innymi funkcjami Angulara, takimi jak system Dependency Injection (DI), co uÅ‚atwia zarzÄ…dzanie zaleÅ¼noÅ›ciami i konfiguracjÄ….

### Inny model komunikacji - WebSockets

Wszystko to, co opisaliÅ›my do tej pory, zakÅ‚ada jednokierunkowÄ… komunikacjÄ™ w modelu â€œpullâ€. Pobieramy z serwera kolejne dane, a uÅ¼ytkownik i warstwa client-side decydujÄ… o tym, kiedy to nastÄ…pi.

Kierunek komunikacji moÅ¼na rozszerzyÄ‡ dziÄ™ki WebSocketom, ktÃ³re umoÅ¼liwiajÄ… dwustronnÄ… komunikacjÄ™ w modelu â€œpushâ€ opartym o publikowanie zdarzeÅ„ z serwera do nasÅ‚uchujÄ…cych klientÃ³w. W przeciwieÅ„stwie do tradycyjnego modelu zapytania i odpowiedzi HTTP, gdzie kaÅ¼da akcja uÅ¼ytkownika wymaga nowego Å¼Ä…dania do serwera, WebSockety utrzymujÄ… otwarte poÅ‚Ä…czenie pomiÄ™dzy warstwami.

Absolutnym liderem w tym obszarze jest biblioteka [Socket.IO](https://socket.io/) (sprawdÅº takÅ¼e [PartyKit](https://www.partykit.io/) oraz [Liveblocks](https://liveblocks.io/)).

**Gdzie wykorzystywane sÄ… WebSockety?**

1. **Aplikacje czatu i komunikatory:** WebSockety sÄ… idealne dla aplikacji, ktÃ³re wymagajÄ… ciÄ…gÅ‚ej wymiany wiadomoÅ›ci miÄ™dzy uÅ¼ytkownikami w czasie rzeczywistym.
    
2. **Gry online:** UmoÅ¼liwiajÄ… szybkÄ… wymianÄ™ informacji o stanie gry, pozycjach graczy, i innych dynamicznie zmieniajÄ…cych siÄ™ danych.
    
3. **Aplikacje finansowe i handel:** W przypadku aplikacji Å›ledzÄ…cych kursy akcji lub walut w czasie rzeczywistym, WebSockety zapewniajÄ… natychmiastowÄ… aktualizacjÄ™ danych.
    
4. **Notyfikacje w czasie rzeczywistym:** Dla aplikacji wymagajÄ…cych informowania uÅ¼ytkownika o nowych zdarzeniach, wiadomoÅ›ciach czy aktualizacjach bez koniecznoÅ›ci odÅ›wieÅ¼ania strony.
    
5. **Dashboardy i monitoring:** Aplikacje do monitorowania danych w czasie rzeczywistym, takie jak dashboardy analityczne, mogÄ… skorzystaÄ‡ na ciÄ…gÅ‚ym strumieniu danych.
    

**Kiedy decydowaÄ‡ siÄ™ na klasycznÄ… komunikacjÄ™ HTTP?**

6. **Aplikacje z maÅ‚Ä… zmiennoÅ›ciÄ… danych:** JeÅ›li aplikacja nie wymaga aktualizacji w czasie rzeczywistym, utrzymanie otwartego poÅ‚Ä…czenia moÅ¼e byÄ‡ niepotrzebne pod wzglÄ™dem zÅ‚oÅ¼onoÅ›ci i zasobÃ³w.
    
7. **Proste strony internetowe:** Dla statycznych stron internetowych, blogÃ³w czy stron informacyjnych, gdzie komunikacja w dwie strony nie jest potrzebna, WebSockety mogÄ… byÄ‡ nadmiarowe.
    
8. **Ograniczenia infrastruktury:** Utrzymanie duÅ¼ej liczby otwartych poÅ‚Ä…czeÅ„ moÅ¼e byÄ‡ wyzwaniem dla serwera, szczegÃ³lnie w systemach rozproszonych i przy zastosowaniu load balancingu.
    

## Podsumowanie

Efektywna komunikacja z API to fundament nowoczesnych aplikacji frontendowych. ChociaÅ¼ pobranie pierwszych bajtÃ³w nie stanowi problemu, to przeksztaÅ‚cenie tego w proces wysokiej jakoÅ›ci, z odpowiednio dobranymi narzÄ™dziami, moÅ¼e stanowiÄ‡ pewne wyzwanie.

Na szczÄ™Å›cie teraz znasz juÅ¼ rÃ³Å¼ne typy zapytaÅ„Â i technologii, ktÃ³re umoÅ¼liwiajÄ… poÅ‚Ä…czenie klienta z serwerem. Wiesz rÃ³wnieÅ¼, na czym polegajÄ… rÃ³Å¼nice pomiÄ™dzy metodami natywnymi (Fetch) a zewnÄ™trznymi bibliotekami (Axios). Potrafisz takÅ¼e rozszerzaÄ‡ istniejÄ…ce rozwiÄ…zania w taki sposÃ³b, aby do zapytaÅ„ dodawaÄ‡ monitoring czy dodatkowe elementy wspomagajÄ…ce debugowanie requestÃ³w.

W kolejnej lekcji zobaczysz czym rÃ³Å¼ni siÄ™ praca z API na produkcji od tego, do czego mÃ³gÅ‚ ciÄ™ przyzwyczaiÄ‡ localhost. Uwierz nam - dopiero tam zaczyna siÄ™ zabawa!