## Wprowadzenie

W tej lekcji przedstawimy ci kilka klasycznych wzorcÃ³w projektowych, ktÃ³re znajdujÄ… swoje zastosowanie na frontendzie - szczegÃ³lnie w bibliotekach i frameworkach, ktÃ³re dostarczajÄ… okreÅ›lony zestaw rozwiÄ…zaÅ„ dla innych programistÃ³w. Podobnie jak w przypadku dobrych praktyk, wzorce potraktuj z odpowiednim dystansem i traktuj je jako opcje, a nie Å›cisÅ‚e reguÅ‚y rozwoju oprogramowania.

Wracaj do tej listy wraz z nabywaniem nowego doÅ›wiadczenia - kaÅ¼dy zrealizowany projekt pozwoli ci spojrzeÄ‡ na tematykÄ™ wzorcÃ³w z nowej strony, a ty zyskasz wiÄ™cej wprawy w ich stosowaniu.

### Wzorce, czyli nawyki programisty

Temat wzorcÃ³w projektowych w Å¼adnym wypadku nie jest nowy - juÅ¼ trzy dekady temu, w ksiÄ…Å¼ce â€œDesign Patterns: Elements of Reusable Object-Oriented Softwareâ€ zauwaÅ¼ono, Å¼e tworzÄ…c oprogramowanie, wiÄ™kszoÅ›Ä‡ problemÃ³w i wyzwaÅ„ moÅ¼na sprowadziÄ‡ do trzech kategorii. SÄ… to:

- ====Jak â€œcoÅ›â€ tworzyÄ‡ w spÃ³jny i powtarzalny sposÃ³b
- ==Jak â€œcoÅ›â€ dziaÅ‚a i jak kontrolowaÄ‡ to zachowanie
- ==Jak to â€œcoÅ›â€ moÅ¼e siÄ™Â komunikowaÄ‡ z innymi elementami systemu====

Lista brzmi sensownie - to faktycznie opis typowych operacji, ktÃ³re musimy kontrolowaÄ‡ tworzÄ…c nasze projekty i aplikacje. PowoÅ‚anie do Å¼ycia nowego elementu (np. komponentu lub obiektu), kontrola nad jego zachowaniem (np. cykl Å¼ycia) oraz komunikacja pomiÄ™dzy wieloma elementami aplikacji (np. nasÅ‚uchiwanie na zmiany aby odÅ›wieÅ¼yÄ‡ widok aplikacji) to zadania, ktÃ³re realizuje niemal kaÅ¼dy programista.

W zwiÄ…zku z tym, autorzy przywoÅ‚anej ksiÄ…Å¼ki zaproponowali trzy gÅ‚Ã³wne kategorie wzorcÃ³w, ktÃ³re warto stosowaÄ‡ w kaÅ¼dym z tych aspektÃ³w:

- ==Wzorce kreacyjne== (obsÅ‚uga tworzenia elementÃ³w systemu)
- ==Wzorce strukturalne== (obsÅ‚uga zachowania elementÃ³w systemu)
- ==Wzorce behawioralne== (obsÅ‚uga komunikacji miÄ™dzy elementami systemu)

ğŸ‘‰ Celem poznania wzorcÃ³w **nie jest** wkuwanie tych kategorii na pamiÄ™Ä‡, ale wyrobienie sobie nawykÃ³w tego, **jak szybko i sprawnie rozwiÄ…zywaÄ‡ typowe, opisywane 30 lat temu problemy programowania**.

Gdzie w takim razie moÅ¼na je spotkaÄ‡ myÅ›lÄ…c o warstwie client-side?

![[Pasted image 20241211153409.png]]
- **ZarzÄ…dzanie stanem** - Frontend czÄ™sto musi radziÄ‡ sobie z dynamicznie zmieniajÄ…cym siÄ™ stanem aplikacji, ktÃ³ry jest reakcjÄ… na interakcje uÅ¼ytkownika oraz dane przychodzÄ…ce z backendu. Wzorce takie jak ==#Flux== pomagajÄ… w organizacji i przewidywaniu zmian w stanie, zapewniajÄ…c jednokierunkowy przepÅ‚yw danych. To z kolei uÅ‚atwia Å›ledzenie, debugowanie i testowanie stanu aplikacji.
    
- **Reakcja na zdarzenia** - Frontend wymaga obsÅ‚ugi zdarzeÅ„ generowanych przez uÅ¼ytkownika (np. klikniÄ™cia, przewijanie) oraz na skutek Å›ledzenia zewnÄ™trznych ÅºrÃ³deÅ‚ danych. Wzorce takie jak ==#Obserwator== lub ==#Pub/Sub== umoÅ¼liwiajÄ… zarzÄ…dzanie tymi zdarzeniami w sposÃ³b zdecentralizowany, bez koniecznoÅ›ci tworzenia skomplikowanych Å‚aÅ„cuchÃ³w zaleÅ¼noÅ›ci miÄ™dzy komponentami.
    
- **AsynchronicznoÅ›Ä‡ -** Åšrodowisko przeglÄ…darki jest z natury asynchroniczne i zdarzeniowe. PrzeglÄ…darka musi rÃ³wnoczeÅ›nie obsÅ‚ugiwaÄ‡ wiele zadaÅ„, takich jak renderowanie interfejsu uÅ¼ytkownika, przetwarzanie zdarzeÅ„ od uÅ¼ytkownika oraz wykonywanie kodu JavaScript. Asynchroniczny kod staje siÄ™ niezbÄ™dny w sytuacjach, gdy dziaÅ‚ania, takie jak zapytania sieciowe, odczytywanie plikÃ³w lub inne operacje I/O, mogÄ… trwaÄ‡ dÅ‚uÅ¼ej. ==Wzorce pracy z asynchronicznym kodem pozwalajÄ… zachowaÄ‡ nad nim kontrolÄ™.
    
- **ZÅ‚oÅ¼onoÅ›Ä‡ projektÃ³w** - WspÃ³Å‚czesne aplikacje frontendowe skÅ‚adajÄ… siÄ™ z wielu moduÅ‚Ã³w i komponentÃ³w. Nikogo nie dziwi juÅ¼ realizowanie peÅ‚noprawnych, rozbudowanych aplikacji z logikÄ… biznesowÄ… w warstwie przeglÄ…darki. Wzorce projektowe takie jak  #Kompozycja , #ModuÅ‚ , czy #Fabryka pozwalajÄ… na projektowanie kodu w sposÃ³b modularny, co uÅ‚atwia jego ponowne wykorzystanie i utrzymanie. DziÄ™ki temu, moÅ¼esz tworzyÄ‡ bardziej zorganizowane, skalowalne i Å‚atwiejsze w utrzymaniu aplikacje, co jest kluczowe przy pracy nad duÅ¼ymi projektami.
    
- **WybÃ³r stacku technologicznego** - Zrozumienie wzorcÃ³w projektowych w praktyce frontendowej moÅ¼e znacznie uÅ‚atwiÄ‡ dobÃ³r odpowiedniego narzÄ™dzia do problemu, ktÃ³ry prÃ³bujesz rozwiÄ…zaÄ‡. WidaÄ‡ to chociaÅ¼by na przykÅ‚adzie reaktywnoÅ›ci i Å›ledzenia zmian, gdzie konkurujÄ… ze sobÄ… podejÅ›cia oparte o Virtual DOM, RxJS albo Signals. MoÅ¼esz decydowaÄ‡ siÄ™ na frameworki wprost korzystajÄ…ce z systemu wstrzykiwania zaleÅ¼noÅ›ci, albo takie, ktÃ³re tego rozwiÄ…zania nie stosujÄ….

W dalszej czÄ™Å›ci lekcji przedstawimy ci kilka popularnych wzorcÃ³w, ktÃ³re warto opanowaÄ‡Â w swojej pracy frontend developera.

ğŸ‘‰ WaÅ¼ne: W omÃ³wieniu wzorcÃ³w celowo wykorzystamy JavaScript i TypeScript - bÄ™dziemy trzymaÄ‡ siÄ™ uniwersalnych przykÅ‚adÃ³w, ktÃ³re moÅ¼esz stosowaÄ‡ niezaleÅ¼nie od wykorzystywanego frameworka. Przede wszystkim ==zwracaj uwagÄ™ na mechanizmy i ogÃ³lny koncept wzorcÃ³w projektowych==, a nie ich detale zwiÄ…zane z okreÅ›lonÄ… implementacjÄ… lub skÅ‚adniÄ… (dziÄ™ki temu unikniesz zÅ‚udzenia, Å¼e wzorce na frontendzie nie majÄ… sensu - to doÅ›Ä‡ powszechne i bÅ‚Ä™dne zaÅ‚oÅ¼enie).

## 1. Wzorzec #Obserwator (_Observer_)

### Scenariusz

WyobraÅº sobie aplikacjÄ™, w ktÃ³rej obiekt globalny (np. koszyk zakupowy) powinien byÄ‡ obserwowany przez rÃ³Å¼ne czÄ™Å›ci interfejsu uÅ¼ytkownika. Chcemy, aby dostÄ™pne komponenty automatycznie reagowaÅ‚y na zmiany tego stanu i aktualizowaÅ‚y siÄ™ w czasie rzeczywistym.

Bez zastosowania odpowiedniego wzorca, moÅ¼esz prÃ³bowaÄ‡ rÄ™cznie odÅ›wieÅ¼aÄ‡ kaÅ¼dy komponent po zmianie stanu. ProwadziÅ‚oby to do prawdziwego spaghetti, gdzie komponenty sÄ… silnie ze sobÄ… powiÄ…zane, a kaÅ¼da zmiana wymaga modyfikacji wielu miejsc w kodzie.

### RozwiÄ…zanie z uÅ¼yciem wzorca Obserwator

Wzorzec Obserwator pozwala komponentom (obserwatorom) subskrybowaÄ‡ na zmiany w obiekcie obserwowanym (np. store). Gdy stan siÄ™ zmienia, obiekt obserwowany powiadamia wszystkich subskrybentÃ³w o **zmianie**.

**PrzykÅ‚ad kodu w TypeScript:**
https://playcode.io/2190157
```typescript
// Typy zdarzeÅ„
type Listener<T> = (state: T) => void;

// Klasa obserwowana (np. Store)
class ObservableStore<T> {
  private state: T;
  private listeners: Listener<T>[] = [];

  constructor(initialState: T) {
    this.state = initialState;
  }

  public subscribe(listener: Listener<T>): () => void {
    this.listeners.push(listener);
    // Zwracamy funkcjÄ™ do odsubskrybowania
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  public update(newState: T): void {
    this.state = newState;
    this.notify();
  }

  private notify(): void {
    this.listeners.forEach(listener => listener(this.state));
  }

  public getState(): T {
    return this.state;
  }
}

// UÅ¼ycie
interface CartItem {
  name: string;
  price: number;
}

interface CartState {
  items: CartItem[];
}

const store = new ObservableStore<CartState>({ items: [] });

// Subskrybent 1 - Wypisanie nazw produktÃ³w
const renderCart = (state: CartState) => {
  const itemNames = state.items.map(item => item.name).join(", ");
  console.log("Aktualny koszyk: ", itemNames);
};

// Subskrybent 2 - Wypisanie Å‚Ä…cznej ceny
const renderTotalPrice = (state: CartState) => {
  const totalPrice = state.items.reduce((total, item) => total + item.price, 0);
  console.log("ÅÄ…czna cena: ", totalPrice);
};

// Subskrybuj na zmiany - w odpowiedzi otrzymasz funkcjÄ™Â do anulowania subskrypcji
const unsubscribeRenderCart = store.subscribe(renderCart);
const unsubscribeRenderTotalPrice = store.subscribe(renderTotalPrice);

// Aktualizuj stan
store.update({ items: [
  { name: "Apple", price: 2 },
  { name: "Banana", price: 3 }
] });

// Aktualny koszyk: Apple, Banana
// ÅÄ…czna cena: 5

// Odsubskrybuj, gdy nie jest juÅ¼ potrzebne wypisywanie nazw
unsubscribeRenderCart();

// Aktualizuj stan po raz drugi
store.update({ items: [
  { name: "Apple", price: 10 }
]});

// ÅÄ…czna cena: 10
```

![[obserwator-diagram.png]]
### Obserwator w akcji

Obserwator to jeden z najpopularniejszych wzorcÃ³w wykorzystywanych na frontendzie. ZarÃ³wno na poziomie duÅ¼ych obiektÃ³w, jak i pojedynczych zmiennych, obserwowanie zmian danego elementu aplikacji to fundament interaktywnych, nowoczesnych rozwiÄ…zaÅ„ client-side.

Co ciekawe, popularna biblioteka Redux niemal w caÅ‚oÅ›ci opiera siÄ™ na obserwatorze. ZachÄ™camy do zapoznania siÄ™ z [detalami](https://github.com/reduxjs/redux), bo dziÄ™ki temu zauwaÅ¼ysz jak niewiele linijek kodu potrzeba aby rozwiÄ…zywaÄ‡ problemy milionÃ³w programistÃ³w na caÅ‚ym Å›wiecie (a to dziÄ™ki wzorcom projektowym).

## 2. Wzorzec #Dekorator (_Decorator_)

### Scenariusz

ZÅ‚oÅ¼one systemy to mnÃ³stwo powiÄ…zaÅ„ pomiÄ™dzy poszczegÃ³lnymi skÅ‚adowymi. Zdarza siÄ™, Å¼e chcemy modyfikowaÄ‡ zachowanie jednego elementu w taki sposÃ³b, aby system caÅ‚y czas dziaÅ‚aÅ‚ stabilnie i przewidywalnie.

Modyfikowanie oryginalnego komponentu za kaÅ¼dym razem, gdy potrzebujemy nowej funkcjonalnoÅ›ci, prowadzi do trudnego w utrzymaniu kodu i Å‚amie zasadÄ™ otwarte-zamkniÄ™te (Open/Closed Principle).

Zamiast tego warto wprowadziÄ‡ nowy obiekt (np. komponent lub funkcjÄ™ dekorujÄ…cÄ…), ktÃ³rÄ… bÄ™dziemy stosowaÄ‡ na Å¼Ä…danie, w Å›ciÅ›le okreÅ›lonych przypadkach.

### RozwiÄ…zanie z uÅ¼yciem wzorca Dekorator

Wzorzec Dekorator pozwala na dynamiczne dodawanie nowych funkcjonalnoÅ›ci do obiektÃ³w, komponentÃ³w lub funkcji poprzez "dekorowanie" ich elementami nadrzÄ™dnymi.

https://playcode.io/2191429
**PrzykÅ‚ad kodu w TypeScript:**
```typescript
// Interfejs komponentu
interface Component {
  render(): void;
}

// Konkretny komponent
class Button implements Component {
  render() {
    console.log("Renderowanie przycisku");
  }
}

// Dekorator bazowy
class ComponentDecorator implements Component {
  protected component: Component;

  constructor(component: Component) {
    this.component = component;
  }

  render() {
    this.component.render();
  }
}

// Konkretne dekoratory
class LoggingDecorator extends ComponentDecorator {
  render() {
    console.log("Log: Przed renderowaniem");
    super.render();
    console.log("Log: Po renderowaniu");
  }
}

class AuthDecorator extends ComponentDecorator {
  render() {
    if (this.checkAccess()) {
      super.render();
    } else {
      console.log("Brak dostÄ™pu");
    }
  }

  private checkAccess(): boolean {
    // Sprawdzenie dostÄ™pu uÅ¼ytkownika
    return true;
  }
}

// UÅ¼ycie
const button = new Button();
const loggedButton = new LoggingDecorator(button);
const securedButton = new AuthDecorator(loggedButton);

securedButton.render();
```

### Dekorator w akcji

Na frontendzie wzorzec Dekorator moÅ¼e mieÄ‡ kilka znaczeÅ„. We frameworkach, ktÃ³re przede wszystkim stawiajÄ… na klasy i obiekty, wzorzec moÅ¼na wykorzystywaÄ‡ korzystajÄ…c z dekoratorÃ³w TypeScripta (np. dekorator ==@Injectable== - sprawienie, aby serwis angularowy byÅ‚ zauwaÅ¼alny przez system do wstrzykiwania zaleÅ¼noÅ›ci). Z kolei w tych frameworkach, ktÃ³re stawiajÄ… na bardziej funkcyjne podejÅ›cie, dekoratorami bÄ™dÄ… ==komponenty wyÅ¼szego rzÄ™du (Higher-Order Components)== lub ==uniwersalne hooki== - sÄ… to rozszerzenia istniejÄ…cych komponentÃ³w, ktÃ³re nie modyfikujÄ… ich podstawowego dziaÅ‚ania.

HOC
https://playcode.io/2191521
```typescript
const withDataFetching = (endpoint: string) => (WrappedComponent: React.ComponentType<any>) => {

Â  return function WithDataFetchingComponent(props) {

Â  Â  const [data, setData] = useState(null);
Â  Â  const [loading, setLoading] = useState(true);
Â  Â  useEffect(() => {
Â  Â  Â  fetch(endpoint)
Â  Â  Â  Â  .then(res => res.json())
Â  Â  Â  Â  .then(data => {
Â  Â  Â  Â  Â  setData(data);
Â  Â  Â  Â  Â  setLoading(false);
Â  Â  Â  Â  });
Â  Â  }, []);

Â  Â  return (
Â  Â  Â  <WrappedComponent
Â  Â  Â  Â  data={data}
Â  Â  Â  Â  loading={loading}
Â  Â  Â  Â  {...props}
Â  Â  Â  />
Â  Â  );
Â  };
};

// UÅ¼ycie
const UserList = ({ data, loading }) => {
Â  if (loading) return <div>Loading...</div>;
Â  return <ul>{data.map(user => <li key={user.id}>{user.name}</li>)}</ul>;
};

const UserListWithData = withDataFetching('/api/users')(UserList);
```

![[decorator-diagram.png]]

## 3. Wzorzec #Proxy (_Proxy_)

### Scenariusz

Zastosowanie wzorca Proxy przypomina to zwiÄ…zane z Dekoratorem. MÃ³wimy o sytuacjach, w ktÃ³rych jeden z obiektÃ³w (np. serwis do pobierania danych lub implementacja algorytmu) powinien zachowywaÄ‡ siÄ™ inaczej niÅ¼ do tej pory, ale musimy to osiÄ…gnÄ…Ä‡ bez naruszania jego struktury.

Zobaczmy to na przykÅ‚adzie komunikacji z API.

### RozwiÄ…zanie z uÅ¼yciem wzorca Proxy

==Wzorzec Proxy wprowadza poÅ›rednika miÄ™dzy klientem (np. komponentem aplikacji) a rzeczywistym ÅºrÃ³dÅ‚em danych (np. backendem z API)==. W poniÅ¼szym przykÅ‚adzie obiekt Proxy przechowuje wyniki zapytaÅ„ i zwraca je z pamiÄ™ci podrÄ™cznej (cache), jeÅ›li dane zostaÅ‚y juÅ¼ pobrane, zamiast wykonywaÄ‡ kolejne zapytania do API. DziÄ™ki temu optymalizujemy wydajnoÅ›Ä‡ aplikacji i zmniejszamy liczbÄ™ zapytaÅ„ do serwera.

**PrzykÅ‚ad kodu w TypeScript:**

```typescript
// Interfejs API
interface UserService {
  fetchUsers(): Promise<string[]>;
}

// Implementacja rzeczywistej usÅ‚ugi
class RealUserService implements UserService {
  async fetchUsers(): Promise<string[]> {
    console.log("Fetching users from API...");
    // Symulacja zapytania do API
    return new Promise((resolve) =>
      setTimeout(() => resolve(["Alice", "Bob", "Charlie"]), 1000)
    );
  }
}

// Proxy dla usÅ‚ugi
class UserServiceProxy implements UserService {
  private realService: UserService;
  private cache: string[] | null = null;

  constructor(realService: UserService) {
    this.realService = realService;
  }

  async fetchUsers(): Promise<string[]> {
    if (this.cache) {
      console.log("Returning cached users...");
      return this.cache;
    }
    console.log("No cache found. Fetching from real service...");
    this.cache = await this.realService.fetchUsers();
    return this.cache;
  }
}

// UÅ¼ycie Proxy w aplikacji
(async () => {
  const realService = new RealUserService();
  const proxy = new UserServiceProxy(realService);

  console.log(await proxy.fetchUsers()); // Fetching from API
  console.log(await proxy.fetchUsers()); // Using cache
})();
```

![[proxy - diagram.png]]
Dla twÃ³rcÃ³w reuÅ¼ywalnych bibliotek i narzÄ™dzi ten wzorzec jest na tyle istotny, Å¼e w standardzie ECMAScript pojawiÅ‚ siÄ™ jakiÅ› czas temu natywny obiekt o tej samej nazwie.

Obiekt Proxy pozwala nam przechwytywaÄ‡ posÅ‚ugiwanie siÄ™Â konkretnymi wÅ‚aÅ›ciwoÅ›ciami obiektu bazowego - w naszym przypadku zareagujemy na uÅ¼ycie funkcji do pobierania danych i wprowadzimy dodatkowÄ… warstwÄ™ zapisywania odpowiedzi:

```typescript
// Rzeczywista usÅ‚uga
class RealUserService {
  async fetchUsers(): Promise<string[]> {
    console.log("Fetching users from API...");
    // Symulacja zapytania do API
    return new Promise((resolve) =>
      setTimeout(() => resolve(["Alice", "Bob", "Charlie"]), 1000)
    );
  }
}

// Tworzenie proxy z cache
const createUserServiceProxy = (realService: RealUserService) => {
  const cache: { [key: string]: any } = {};

  // Wykorzystanie natywnego obiektu Proxy
  return new Proxy(realService, {
    get(target, property) {
      if (property === "fetchUsers") {
        // JeÅ›li dane sÄ… w cache, zwracamy je
        if (cache[property]) {
          console.log("Returning cached users...");
          return () => Promise.resolve(cache[property]);
        }

        // JeÅ›li dane nie sÄ… w cache, wykonujemy rzeczywiste wywoÅ‚anie
        return async (...args: any[]) => {
          console.log("No cache found. Fetching from real service...");
          const result = await target[property as keyof RealUserService](...args);
          cache[property] = result; // Zapisujemy dane w cache
          return result;
        };
      }

      // Dla innych wÅ‚aÅ›ciwoÅ›ci delegujemy wywoÅ‚anie do rzeczywistego obiektu
      return target[property as keyof RealUserService];
    },
  });
};

// UÅ¼ycie Proxy
(async () => {
  const realService = new RealUserService();
  const userServiceProxy = createUserServiceProxy(realService);

  console.log(await userServiceProxy.fetchUsers()); // Fetching from API
  console.log(await userServiceProxy.fetchUsers()); // Using cache
})();
```

### Proxy a Dekorator

Jak czÄ™sto bywa w programowaniu, oba wzorce mogÄ… byÄ‡ wykorzystywane do realizowania podobnych zadaÅ„. GÅ‚Ã³wna rÃ³Å¼nica polega na tym, jakÄ… wiedzÄ™ o obiekcie bazowym bÄ™dÄ… one posiadaÄ‡. Proxy jest zdecydowanie mocniej powiÄ…zane z tym, co kontroluje lub rozszerza, a Dekoratory budowane sÄ… w sposÃ³b bardziej uniwersalny aby akceptowaÄ‡ rÃ³Å¼ne argumenty.

W teorii zwykÅ‚o siÄ™ powtarzaÄ‡, Å¼e Proxy sÅ‚uÅ¼y do â€œkontroliâ€ zachowania lub dostÄ™pu do obiektu a Dekorator do â€œrozszerzania obiektuâ€, ale w praktyce trudno ustawiÄ‡ tutaj jasnÄ… granicÄ™.

To, co oba wzorce wyrÃ³Å¼nia, to jawnoÅ›Ä‡ ich stosowania - Proxy ma byÄ‡ niewidocznÄ… czarnÄ… skrzynkÄ…, ktÃ³rÄ… moÅ¼na zawsze podstawiÄ‡ w miejsce obiektu bazowego, a Dekorator zawsze bÄ™dzie siÄ™ wyrÃ³Å¼niaÅ‚ jako coÅ› nowego:

- Proxy - odÅ›wieÅ¼ona wersja tego samego modelu samochodu (Fiat z 2023 â†’ Fiat z 2024)
    
- Dekorator - zamiana aktualnego samochodu na model z wyÅ¼szej pÃ³Å‚ki (Fiat â†’ Ferrari)
    

### Proxy w akcji

Zastosowanie wzorca Proxy poznasz w lekcjach o bezpiecznej komunikacji z API. Obiekt Proxy posÅ‚uÅ¼y nam do modyfikowania klientÃ³w HTTP - to jedno z najbardziej powszechnych zastosowaÅ„ tego wzorca.

## 4. Wzorzec #Adapter (_Adapter_)

### Scenariusz

WyobraÅº sobie scenariusz, w ktÃ³rym jeden z czÅ‚onkÃ³w zespoÅ‚u chce do projektu wprowadziÄ‡ nowÄ… praktykÄ™ komunikacji z API. PrzykÅ‚adowo, jeszcze kilka lat temu byÅ‚o to przejÅ›cie z popularnego modelu opartego o tzw. callbacki na obiekt Promise.

Jak to zrobiÄ‡, kiedy w kodzie roi siÄ™Â od funkcji zrealizowanych w starszy sposÃ³b, z ktÃ³rych korzystajÄ… juÅ¼ inne zespoÅ‚y i produkty? Czy twÃ³j pomysÅ‚ pozostanie w sferze marzeÅ„?

### RozwiÄ…zanie z uÅ¼yciem wzorca Adapter

==Zastosowanie wzorca Adapter pozwala na integracjÄ™ dwÃ³ch rÃ³Å¼nych komponentÃ³w lub sposobÃ³w na realizacjÄ™ podobnego zadania==. PrzykÅ‚adowo, aby umoÅ¼liwiÄ‡ komunikacjÄ™ z API opartÄ… o Promise, bez zaleÅ¼noÅ›ci na callbacki, moÅ¼na wprowadziÄ‡ tymczasowy Adapter i wypromowaÄ‡ jego stosowanie w firmie.

W momencie, kiedy caÅ‚a organizacja zacznie z niego korzystaÄ‡, wystarczy podmieniÄ‡ wewnÄ™trznÄ… implementacjÄ™ i usunÄ…Ä‡ stary kod z callbackami.

https://playcode.io/2194589

**PrzykÅ‚ad kodu w TypeScript:**

```typescript
// IstniejÄ…ca klasa, w ktÃ³rej do obsÅ‚ugi asynchronicznoÅ›ci wykorzystujemy callbacki
class LegacyAPIClient {
  fetchData(endpoint: string, callback: (data: any) => void): void {
    // Symulacja pobierania danych
    setTimeout(() => {
      callback({ data: "Dane z zewnÄ™trznego API" });
    }, 1000);
  }
}

// Nowy interfejs oparty na Promisach
interface ModernAPIClient {
  get(url: string): Promise<any>;
}

// Adapter - komunikacja z API oparta na Promisach, ukrywajÄ…ca starsze podejÅ›cie
class APIClient implements ModernAPIClient {
  private externalApi: LegacyAPIClient;

  constructor() {
    this.externalApi = new LegacyAPIClient();
  }

  get(url: string): Promise<any> {
    return new Promise((resolve) => {
      this.externalApi.fetchData(url, (data) => {
        resolve(data);
      });
    });
  }
}

// UÅ¼ycie nowego rozwiÄ…zania
const httpClient: ModernAPIClient = new APIClient();

(async () => {
  const data = await httpClient.get("/endpoint");
  console.log(data);
})();
```
### Adapter w akcji

Na frontendzie adapter sprawdzi siÄ™ wszÄ™dzie tam, kiedy integrujemy ze sobÄ… dwa konfliktowe podejÅ›cie do realizacji okreÅ›lonego zadania. MoÅ¼e to byÄ‡ sposÃ³b komunikacji z API, moÅ¼e to byÄ‡ nowy format komponentÃ³w lub fragment logiki biznesowej, gdzie zaleÅ¼y nam na kluczowej zmianie. Wprowadzenie tymczasowego adaptera pozwoli przykryÄ‡ rÃ³Å¼nice w dwÃ³ch elementach i przeprowadziÄ‡ proces migracji z bezproblemowy sposÃ³b.

## 5. Wzorzec #Fasada (_Facade_)

### Scenariusz

Twoja aplikacja korzysta z wielu zÅ‚oÅ¼onych moduÅ‚Ã³w, funkcji lub bibliotek do komunikacji z backendem. Nie masz kontroli nad tym kto i kiedy komunikuje siÄ™ z API, przez co wprowadzanie nowoÅ›ci takich jak logowanie czy monitoring, ktÃ³re poznasz w kolejnych lekcjach, wymaga zmian w wielu miejscach jednoczeÅ›nie.

Akceptowanie takiego sposobu rozwijania projektu moÅ¼e prowadziÄ‡ do trudniejszego wdraÅ¼ania nowych programistÃ³w, mniej efektywnego analizowania bÅ‚Ä™dÃ³w produkcyjnych i powolnego implementowania usprawnieÅ„. Potrzebujesz czegoÅ›, co ujednolici komunikacjÄ™ miÄ™dzy frontendem i backendem na przestrzeni caÅ‚ego projektu.

### RozwiÄ…zanie z uÅ¼yciem wzorca Fasada

==Wzorzec Fasada pozwoli nam wprowadziÄ‡ jednolitego klienta (zwyczajowa nazwa takich moduÅ‚Ã³w) do API, ktÃ³ry przejmie odpowiedzialnoÅ›Ä‡ za wykonywanie zapytaÅ„==. Od teraz kaÅ¼dy, kto bÄ™dzie chciaÅ‚ pobraÄ‡ dane ze zdalnego ÅºrÃ³dÅ‚a, bÄ™dzie robiÅ‚ to w jednolity sposÃ³b.

W przypadku wprowadzania rozszerzeÅ„ sÅ‚uÅ¼Ä…cych do monitoringu, logowania czy analizy wydajnoÅ›ci zapytaÅ„, caÅ‚a praca ograniczy siÄ™ do jednej klasy lub serwisu.

https://playcode.io/2195585

```typescript
/ Rozproszone moduÅ‚y do komunikacji z backendem
class AuthenticationService {
  login(user: string, pass: string): Promise<boolean> {
    // Logika logowania
    return Promise.resolve(true);
  }
}

class DataService {
  fetchData(): Promise<any> {
    // Pobieranie danych
    return Promise.resolve({ data: "Dane" });
  }
}

class LoggingService {
  log(message: string): void {
    console.log("Log:", message);
  }
}

// Jednolity klient API (Fasada)
class ApiClient {
  private authService = new AuthenticationService();
  private dataService = new DataService();
  private loggingService = new LoggingService();

  /**
   * Logowanie uÅ¼ytkownika
   * @param user - nazwa uÅ¼ytkownika
   * @param pass - hasÅ‚o uÅ¼ytkownika
   */
  async login(user: string, pass: string): Promise<void> {
    this.loggingService.log("PrÃ³ba logowania");
    const success = await this.authService.login(user, pass);
    if (!success) {
      this.loggingService.log("Logowanie nieudane");
      throw new Error("NieprawidÅ‚owe dane logowania");
    }
    this.loggingService.log("Logowanie zakoÅ„czone sukcesem");
  }

  /**
   * Pobranie danych po zalogowaniu
   */
  async getData(): Promise<any> {
    this.loggingService.log("RozpoczÄ™to pobieranie danych");
    const data = await this.dataService.fetchData();
    this.loggingService.log("Dane zostaÅ‚y pobrane");
    return data;
  }

  /**
   * Logowanie i pobieranie danych w jednej operacji
   * @param user - nazwa uÅ¼ytkownika
   * @param pass - hasÅ‚o uÅ¼ytkownika
   */
  async loginAndFetchData(user: string, pass: string): Promise<any> {
    await this.login(user, pass);
    return this.getData();
  }
}

// UÅ¼ycie
const apiClient = new ApiClient();

apiClient.loginAndFetchData("user", "pass")
  .then((data) => {
    console.log("Otrzymane dane:", data);
  })
  .catch((error) => {
    console.error("BÅ‚Ä…d:", error.message);
  });
```

### Fasada w akcji

Na pierwszy rzut oka Fasada moÅ¼e ograniczaÄ‡ moÅ¼liwoÅ›ci programistÃ³w w porÃ³wnaniu do pracy z jej skÅ‚adowymi, ale wbrew pozorom wiele aplikacji moÅ¼e na tym skorzystaÄ‡. WszÄ™dzie tam, gdzie zauwaÅ¼asz rÃ³Å¼ne podejÅ›cia do rozwiÄ…zania tego samego problemu, rozwaÅ¼ wprowadzenie opisywanego wzorca.

## 6. Wzorzec #Strategia (_Strategy_)

### Scenariusz

==Zdarza siÄ™, Å¼e aby zapewniÄ‡ interaktywnoÅ›Ä‡ aplikacji frontendowych, ich zachowanie musi zmieniaÄ‡ siÄ™ w locie, bez przeÅ‚adowania strony lub bez zapisywania nowego stanu w bazie.== PrzykÅ‚adowÄ… zmianÄ… moÅ¼e byÄ‡ chociaÅ¼by filtrowanie list w zgodzie z wieloma rÃ³Å¼nymi kryteriami, na ktÃ³re zdecyduje siÄ™ uÅ¼ytkownik.

Naiwne podejÅ›cie do rozwiÄ…zania tego problemu bÄ™dzie polegaÅ‚o na wprowadzeniu wielu instrukcji warunkowych (if, switch) wewnÄ…trz komponentu. W efekcie doprowadzi to do skomplikowanego i trudnego w utrzymaniu kodu.

### RozwiÄ…zanie z uÅ¼yciem wzorca Strategia

==Wzorzec Strategia pozwala zdefiniowaÄ‡ rodzinÄ™ algorytmÃ³w, umieÅ›ciÄ‡ je w osobnych klasach lub funkcjach i uczyniÄ‡ je wymienialnymi w czasie dziaÅ‚ania programu==.

https://playcode.io/2195775

**PrzykÅ‚ad kodu w TypeScript:**

```typescript
/ Model produktu
interface Product {
  name: string;
  price: number;
  popularity: number;
}

// Funkcje jako strategie sortowania
const sortByPriceAsc = (products: Product[]): Product[] =>
  products.slice().sort((a, b) => a.price - b.price);

const sortByPriceDesc = (products: Product[]): Product[] =>
  products.slice().sort((a, b) => b.price - a.price);

const sortByPopularity = (products: Product[]): Product[] =>
  products.slice().sort((a, b) => b.popularity - a.popularity);

const sortByName = (products: Product[]): Product[] =>
  products.slice().sort((a, b) => a.name.localeCompare(b.name));

// Klasa kontekstowa lub docelowy komponent
class ProductList {
  private products: Product[];
  private sortStrategy: (products: Product[]) => Product[];

  constructor(
    products: Product[],
    sortStrategy: (products: Product[]) => Product[]
  ) {
    this.products = products;
    this.sortStrategy = sortStrategy;
  }

  // Ustawienie strategii sortowania
  setSortStrategy(sortStrategy: (products: Product[]) => Product[]) {
    this.sortStrategy = sortStrategy;
  }

  // Pobranie posortowanych produktÃ³w
  getSortedProducts(): Product[] {
    return this.sortStrategy(this.products);
  }
}

// UÅ¼ycie wzorca Strategia
const products: Product[] = [
  { name: "Laptop", price: 1200, popularity: 95 },
  { name: "Smartphone", price: 800, popularity: 120 },
  { name: "Headphones", price: 200, popularity: 300 },
  { name: "Keyboard", price: 100, popularity: 150 },
];

// Tworzymy listÄ™ produktÃ³w z domyÅ›lnÄ… strategiÄ… sortowania
const productList = new ProductList(products, sortByPriceAsc);
console.log("Sortowanie wedÅ‚ug ceny (rosnÄ…co):", productList.getSortedProducts());

// Zmieniamy strategiÄ™ na sortowanie wedÅ‚ug popularnoÅ›ci
productList.setSortStrategy(sortByPopularity);
console.log("Sortowanie wedÅ‚ug popularnoÅ›ci:", productList.getSortedProducts());

// Zmieniamy strategiÄ™ na sortowanie wedÅ‚ug nazwy
productList.setSortStrategy(sortByName);
console.log("Sortowanie wedÅ‚ug nazwy:", productList.getSortedProducts());
```

## 7. Wzorzec Dusiciel (_Strangler Fig_)

To wzorzec, ktÃ³ry nie jest Å›ciÅ›le powiÄ…zany ze strukturÄ… kodu, ale moÅ¼e byÄ‡ przydatny w momencie realizowania bardziej strategicznych inicjatyw. Jego nazwa inspirowana jest [tropikalnÄ… roÅ›linnoÅ›ciÄ…](https://en.wikipedia.org/wiki/Strangler_fig) (dosÅ‚ownie figowiec dusiciel), ktÃ³ra sÅ‚ynie ze swojego unikalnego sposobu wzrostu, polegajÄ…cego na oplataniu siÄ™ wokÃ³Å‚ drzewa-gospodarza.

Strangler Pattern polega na stopniowym zastÄ™powaniu fragmentÃ³w starego systemu (tzw. monolitu lub legacy code) nowym kodem, aÅ¼ do caÅ‚kowitej eliminacji starej implementacji.

### Scenariusz

JeÅ›li bÄ™dziesz miaÅ‚ szansÄ™ popracowaÄ‡ w firmie, ktÃ³ra rozwija jeden projekt przez wiele lat, byÄ‡ moÅ¼e twoim zadaniem stanie siÄ™ stopniowe migrowanie przestarzaÅ‚ej technologii do nowego stacku technicznego, bez przerywania dziaÅ‚ania aplikacji.

Przepisywanie caÅ‚ej aplikacji od zera to domyÅ›lny pomysÅ‚ wielu poczÄ…tkujÄ…cych, ale jest to niezmiernie ryzykowne i moÅ¼e prowadziÄ‡ do dÅ‚ugich przestojÃ³w oraz bÅ‚Ä™dÃ³w wynikajÄ…cych z tzw. â€œbig bang releaseâ€.

Do tego, wyrÃ³wnanie funkcjonalnoÅ›ci nowej aplikacji, kiedy stara jest wciÄ…Å¼ utrzymywana, moÅ¼e zamieniÄ‡ siÄ™ w wyÅ›cig bez mety na horyzoncie.

### RozwiÄ…zanie z uÅ¼yciem wzorca Strangler Fig

WyobraÅºmy sobie aplikacjÄ™ frontendowÄ… napisanÄ… w przestarzaÅ‚ej technologii (np. jQuery), ktÃ³rÄ… chcemy stopniowo migrowaÄ‡ do Reacta lub innego nowoczesnego frameworka, bez jednorazowego przepisywania caÅ‚ego projektu.

## Podsumowanie

Wiele nieporozumieÅ„ zwiÄ…zanych ze stosowaniem wzorcÃ³w projektowych na frontendzie wynika z traktowania ich w zbyt dosÅ‚owny sposÃ³b.

Jeszcze raz podkreÅ›lamy, Å¼e ==wzorce nie powinny dziaÅ‚aÄ‡ jak wyuczone na pamiÄ™Ä‡ formuÅ‚ki, ale jak ustandaryzowane mechanizmy lub akcje, ktÃ³re moÅ¼na implementowaÄ‡ w dowolnej technologii==.

Przy pracy z frontendem kluczowe jest rozumienie celu, jaki dany wzorzec ma osiÄ…gnÄ…Ä‡, oraz kontekstu, w jakim jest stosowany. Dla przykÅ‚adu:

- **Wzorzec Obserwator** moÅ¼e byÄ‡ realizowany za pomocÄ… natywnych zdarzeÅ„ JavaScript, bibliotek takich jak RxJS, czy teÅ¼ w kontekÅ›cie frameworkÃ³w jak Angular lub React.
    
- **Wzorzec Strategia** pozwala na budowanie elastycznych rozwiÄ…zaÅ„, na przykÅ‚ad w zarzÄ…dzaniu rÃ³Å¼nymi ==strategiami walidacji formularzy==.
    
- **Wzorzec Adapter** przydaje siÄ™ do ==porzÄ…dkowania warstwy komunikacji z API==, ktÃ³ra w wielu projektach jest najmniej uporzÄ…dkowanym elementem caÅ‚ej ukÅ‚adanki.
    

NiektÃ³re wzorce mogÄ… byÄ‡ wbudowane w dany framework (np. Dependency Injection w Angularze), podczas gdy inne trzeba implementowaÄ‡ manualnie, uwzglÄ™dniajÄ…c ograniczenia Å›rodowiska. WaÅ¼ne, by patrzeÄ‡ na wzorce projektowe jak na narzÄ™dzia, a nie jak na obowiÄ…zkowe schematy do implementacji.

Warto jednak pamiÄ™taÄ‡, Å¼e tego typu zbiÃ³r narzÄ™dzi istnieje i co wiÄ™cej, rozwijany jest zdecydowanie dÅ‚uÅ¼ej niÅ¼ to, co uznajemy za wspÃ³Å‚czesny frontend epoki Angulara, Vue czy Reacta.