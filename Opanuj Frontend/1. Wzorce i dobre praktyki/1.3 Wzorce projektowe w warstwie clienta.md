## Wprowadzenie

W tej lekcji przedstawimy ci kilka klasycznych wzorcÃ³w projektowych, ktÃ³re znajdujÄ… swoje zastosowanie na frontendzie - szczegÃ³lnie w bibliotekach i frameworkach, ktÃ³re dostarczajÄ… okreÅ›lony zestaw rozwiÄ…zaÅ„ dla innych programistÃ³w. Podobnie jak w przypadku dobrych praktyk, wzorce potraktuj z odpowiednim dystansem i traktuj je jako opcje, a nie Å›cisÅ‚e reguÅ‚y rozwoju oprogramowania.

Wracaj do tej listy wraz z nabywaniem nowego doÅ›wiadczenia - kaÅ¼dy zrealizowany projekt pozwoli ci spojrzeÄ‡ na tematykÄ™ wzorcÃ³w z nowej strony, a ty zyskasz wiÄ™cej wprawy w ich stosowaniu.

### Wzorce, czyli nawyki programisty

Temat wzorcÃ³w projektowych w Å¼adnym wypadku nie jest nowy - juÅ¼ trzy dekady temu, w ksiÄ…Å¼ce â€œDesign Patterns: Elements of Reusable Object-Oriented Softwareâ€ zauwaÅ¼ono, Å¼e tworzÄ…c oprogramowanie, wiÄ™kszoÅ›Ä‡ problemÃ³w i wyzwaÅ„ moÅ¼na sprowadziÄ‡ do trzech kategorii. SÄ… to:

- ====Jak â€œcoÅ›â€ tworzyÄ‡ w spÃ³jny i powtarzalny sposÃ³b
- ==Jak â€œcoÅ›â€ dziaÅ‚a i jak kontrolowaÄ‡ to zachowanie
- ==Jak to â€œcoÅ›â€ moÅ¼e siÄ™Â komunikowaÄ‡ z innymi elementami systemu====

Lista brzmi sensownie - to faktycznie opis typowych operacji, ktÃ³re musimy kontrolowaÄ‡ tworzÄ…c nasze projekty i aplikacje. PowoÅ‚anie do Å¼ycia nowego elementu (np. komponentu lub obiektu), kontrola nad jego zachowaniem (np. cykl Å¼ycia) oraz komunikacja pomiÄ™dzy wieloma elementami aplikacji (np. nasÅ‚uchiwanie na zmiany aby odÅ›wieÅ¼yÄ‡ widok aplikacji) to zadania, ktÃ³re realizuje niemal kaÅ¼dy programista.

W zwiÄ…zku z tym, autorzy przywoÅ‚anej ksiÄ…Å¼ki zaproponowali trzy gÅ‚Ã³wne kategorie wzorcÃ³w, ktÃ³re warto stosowaÄ‡ w kaÅ¼dym z tych aspektÃ³w:

- ==Wzorce kreacyjne== (obsÅ‚uga tworzenia elementÃ³w systemu)
- ==Wzorce strukturalne== (obsÅ‚uga zachowania elementÃ³w systemu)
- ==Wzorce behawioralne== (obsÅ‚uga komunikacji miÄ™dzy elementami systemu)

ğŸ‘‰ Celem poznania wzorcÃ³w **nie jest** wkuwanie tych kategorii na pamiÄ™Ä‡, ale wyrobienie sobie nawykÃ³w tego, **jak szybko i sprawnie rozwiÄ…zywaÄ‡ typowe, opisywane 30 lat temu problemy programowania**.

Gdzie w takim razie moÅ¼na je spotkaÄ‡ myÅ›lÄ…c o warstwie client-side?

![[Pasted image 20241211153409.png]]
- **ZarzÄ…dzanie stanem** - Frontend czÄ™sto musi radziÄ‡ sobie z dynamicznie zmieniajÄ…cym siÄ™ stanem aplikacji, ktÃ³ry jest reakcjÄ… na interakcje uÅ¼ytkownika oraz dane przychodzÄ…ce z backendu. Wzorce takie jak ==#Flux== pomagajÄ… w organizacji i przewidywaniu zmian w stanie, zapewniajÄ…c jednokierunkowy przepÅ‚yw danych. To z kolei uÅ‚atwia Å›ledzenie, debugowanie i testowanie stanu aplikacji.
    
- **Reakcja na zdarzenia** - Frontend wymaga obsÅ‚ugi zdarzeÅ„ generowanych przez uÅ¼ytkownika (np. klikniÄ™cia, przewijanie) oraz na skutek Å›ledzenia zewnÄ™trznych ÅºrÃ³deÅ‚ danych. Wzorce takie jak ==#Obserwator== lub ==#Pub/Sub== umoÅ¼liwiajÄ… zarzÄ…dzanie tymi zdarzeniami w sposÃ³b zdecentralizowany, bez koniecznoÅ›ci tworzenia skomplikowanych Å‚aÅ„cuchÃ³w zaleÅ¼noÅ›ci miÄ™dzy komponentami.
    
- **AsynchronicznoÅ›Ä‡ -** Åšrodowisko przeglÄ…darki jest z natury asynchroniczne i zdarzeniowe. PrzeglÄ…darka musi rÃ³wnoczeÅ›nie obsÅ‚ugiwaÄ‡ wiele zadaÅ„, takich jak renderowanie interfejsu uÅ¼ytkownika, przetwarzanie zdarzeÅ„ od uÅ¼ytkownika oraz wykonywanie kodu JavaScript. Asynchroniczny kod staje siÄ™ niezbÄ™dny w sytuacjach, gdy dziaÅ‚ania, takie jak zapytania sieciowe, odczytywanie plikÃ³w lub inne operacje I/O, mogÄ… trwaÄ‡ dÅ‚uÅ¼ej. ==Wzorce pracy z asynchronicznym kodem pozwalajÄ… zachowaÄ‡ nad nim kontrolÄ™.
    
- **ZÅ‚oÅ¼onoÅ›Ä‡ projektÃ³w** - WspÃ³Å‚czesne aplikacje frontendowe skÅ‚adajÄ… siÄ™ z wielu moduÅ‚Ã³w i komponentÃ³w. Nikogo nie dziwi juÅ¼ realizowanie peÅ‚noprawnych, rozbudowanych aplikacji z logikÄ… biznesowÄ… w warstwie przeglÄ…darki. Wzorce projektowe takie jak  #Kompozycja , #ModuÅ‚ , czy #Fabryka pozwalajÄ… na projektowanie kodu w sposÃ³b modularny, co uÅ‚atwia jego ponowne wykorzystanie i utrzymanie. DziÄ™ki temu, moÅ¼esz tworzyÄ‡ bardziej zorganizowane, skalowalne i Å‚atwiejsze w utrzymaniu aplikacje, co jest kluczowe przy pracy nad duÅ¼ymi projektami.
    
- **WybÃ³r stacku technologicznego** - Zrozumienie wzorcÃ³w projektowych w praktyce frontendowej moÅ¼e znacznie uÅ‚atwiÄ‡ dobÃ³r odpowiedniego narzÄ™dzia do problemu, ktÃ³ry prÃ³bujesz rozwiÄ…zaÄ‡. WidaÄ‡ to chociaÅ¼by na przykÅ‚adzie reaktywnoÅ›ci i Å›ledzenia zmian, gdzie konkurujÄ… ze sobÄ… podejÅ›cia oparte o Virtual DOM, RxJS albo Signals. MoÅ¼esz decydowaÄ‡ siÄ™ na frameworki wprost korzystajÄ…ce z systemu wstrzykiwania zaleÅ¼noÅ›ci, albo takie, ktÃ³re tego rozwiÄ…zania nie stosujÄ….

W dalszej czÄ™Å›ci lekcji przedstawimy ci kilka popularnych wzorcÃ³w, ktÃ³re warto opanowaÄ‡Â w swojej pracy frontend developera.

ğŸ‘‰ WaÅ¼ne: W omÃ³wieniu wzorcÃ³w celowo wykorzystamy JavaScript i TypeScript - bÄ™dziemy trzymaÄ‡ siÄ™ uniwersalnych przykÅ‚adÃ³w, ktÃ³re moÅ¼esz stosowaÄ‡ niezaleÅ¼nie od wykorzystywanego frameworka. Przede wszystkim ==zwracaj uwagÄ™ na mechanizmy i ogÃ³lny koncept wzorcÃ³w projektowych==, a nie ich detale zwiÄ…zane z okreÅ›lonÄ… implementacjÄ… lub skÅ‚adniÄ… (dziÄ™ki temu unikniesz zÅ‚udzenia, Å¼e wzorce na frontendzie nie majÄ… sensu - to doÅ›Ä‡ powszechne i bÅ‚Ä™dne zaÅ‚oÅ¼enie).

## 1. Wzorzec #Obserwator (_Observer_)

### Scenariusz

WyobraÅº sobie aplikacjÄ™, w ktÃ³rej obiekt globalny (np. koszyk zakupowy) powinien byÄ‡ obserwowany przez rÃ³Å¼ne czÄ™Å›ci interfejsu uÅ¼ytkownika. Chcemy, aby dostÄ™pne komponenty automatycznie reagowaÅ‚y na zmiany tego stanu i aktualizowaÅ‚y siÄ™ w czasie rzeczywistym.

Bez zastosowania odpowiedniego wzorca, moÅ¼esz prÃ³bowaÄ‡ rÄ™cznie odÅ›wieÅ¼aÄ‡ kaÅ¼dy komponent po zmianie stanu. ProwadziÅ‚oby to do prawdziwego spaghetti, gdzie komponenty sÄ… silnie ze sobÄ… powiÄ…zane, a kaÅ¼da zmiana wymaga modyfikacji wielu miejsc w kodzie.

### RozwiÄ…zanie z uÅ¼yciem wzorca Obserwator

Wzorzec Obserwator pozwala komponentom (obserwatorom) subskrybowaÄ‡ na zmiany w obiekcie obserwowanym (np. store). Gdy stan siÄ™ zmienia, obiekt obserwowany powiadamia wszystkich subskrybentÃ³w o **zmianie**.

**PrzykÅ‚ad kodu w TypeScript:**
https://playcode.io/2190157
```typescript
// Typy zdarzeÅ„
type Listener<T> = (state: T) => void;

// Klasa obserwowana (np. Store)
class ObservableStore<T> {
  private state: T;
  private listeners: Listener<T>[] = [];

  constructor(initialState: T) {
    this.state = initialState;
  }

  public subscribe(listener: Listener<T>): () => void {
    this.listeners.push(listener);
    // Zwracamy funkcjÄ™ do odsubskrybowania
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  public update(newState: T): void {
    this.state = newState;
    this.notify();
  }

  private notify(): void {
    this.listeners.forEach(listener => listener(this.state));
  }

  public getState(): T {
    return this.state;
  }
}

// UÅ¼ycie
interface CartItem {
  name: string;
  price: number;
}

interface CartState {
  items: CartItem[];
}

const store = new ObservableStore<CartState>({ items: [] });

// Subskrybent 1 - Wypisanie nazw produktÃ³w
const renderCart = (state: CartState) => {
  const itemNames = state.items.map(item => item.name).join(", ");
  console.log("Aktualny koszyk: ", itemNames);
};

// Subskrybent 2 - Wypisanie Å‚Ä…cznej ceny
const renderTotalPrice = (state: CartState) => {
  const totalPrice = state.items.reduce((total, item) => total + item.price, 0);
  console.log("ÅÄ…czna cena: ", totalPrice);
};

// Subskrybuj na zmiany - w odpowiedzi otrzymasz funkcjÄ™Â do anulowania subskrypcji
const unsubscribeRenderCart = store.subscribe(renderCart);
const unsubscribeRenderTotalPrice = store.subscribe(renderTotalPrice);

// Aktualizuj stan
store.update({ items: [
  { name: "Apple", price: 2 },
  { name: "Banana", price: 3 }
] });

// Aktualny koszyk: Apple, Banana
// ÅÄ…czna cena: 5

// Odsubskrybuj, gdy nie jest juÅ¼ potrzebne wypisywanie nazw
unsubscribeRenderCart();

// Aktualizuj stan po raz drugi
store.update({ items: [
  { name: "Apple", price: 10 }
]});

// ÅÄ…czna cena: 10
```

![[obserwator-diagram.png]]
### Obserwator w akcji

Obserwator to jeden z najpopularniejszych wzorcÃ³w wykorzystywanych na frontendzie. ZarÃ³wno na poziomie duÅ¼ych obiektÃ³w, jak i pojedynczych zmiennych, obserwowanie zmian danego elementu aplikacji to fundament interaktywnych, nowoczesnych rozwiÄ…zaÅ„ client-side.

Co ciekawe, popularna biblioteka Redux niemal w caÅ‚oÅ›ci opiera siÄ™ na obserwatorze. ZachÄ™camy do zapoznania siÄ™ z [detalami](https://github.com/reduxjs/redux), bo dziÄ™ki temu zauwaÅ¼ysz jak niewiele linijek kodu potrzeba aby rozwiÄ…zywaÄ‡ problemy milionÃ³w programistÃ³w na caÅ‚ym Å›wiecie (a to dziÄ™ki wzorcom projektowym).

## 2. Wzorzec #Dekorator (_Decorator_)

### Scenariusz

ZÅ‚oÅ¼one systemy to mnÃ³stwo powiÄ…zaÅ„ pomiÄ™dzy poszczegÃ³lnymi skÅ‚adowymi. Zdarza siÄ™, Å¼e chcemy modyfikowaÄ‡ zachowanie jednego elementu w taki sposÃ³b, aby system caÅ‚y czas dziaÅ‚aÅ‚ stabilnie i przewidywalnie.

Modyfikowanie oryginalnego komponentu za kaÅ¼dym razem, gdy potrzebujemy nowej funkcjonalnoÅ›ci, prowadzi do trudnego w utrzymaniu kodu i Å‚amie zasadÄ™ otwarte-zamkniÄ™te (Open/Closed Principle).

Zamiast tego warto wprowadziÄ‡ nowy obiekt (np. komponent lub funkcjÄ™ dekorujÄ…cÄ…), ktÃ³rÄ… bÄ™dziemy stosowaÄ‡ na Å¼Ä…danie, w Å›ciÅ›le okreÅ›lonych przypadkach.

### RozwiÄ…zanie z uÅ¼yciem wzorca Dekorator

Wzorzec Dekorator pozwala na dynamiczne dodawanie nowych funkcjonalnoÅ›ci do obiektÃ³w, komponentÃ³w lub funkcji poprzez "dekorowanie" ich elementami nadrzÄ™dnymi.

https://playcode.io/2191429
**PrzykÅ‚ad kodu w TypeScript:**
```typescript
// Interfejs komponentu
interface Component {
  render(): void;
}

// Konkretny komponent
class Button implements Component {
  render() {
    console.log("Renderowanie przycisku");
  }
}

// Dekorator bazowy
class ComponentDecorator implements Component {
  protected component: Component;

  constructor(component: Component) {
    this.component = component;
  }

  render() {
    this.component.render();
  }
}

// Konkretne dekoratory
class LoggingDecorator extends ComponentDecorator {
  render() {
    console.log("Log: Przed renderowaniem");
    super.render();
    console.log("Log: Po renderowaniu");
  }
}

class AuthDecorator extends ComponentDecorator {
  render() {
    if (this.checkAccess()) {
      super.render();
    } else {
      console.log("Brak dostÄ™pu");
    }
  }

  private checkAccess(): boolean {
    // Sprawdzenie dostÄ™pu uÅ¼ytkownika
    return true;
  }
}

// UÅ¼ycie
const button = new Button();
const loggedButton = new LoggingDecorator(button);
const securedButton = new AuthDecorator(loggedButton);

securedButton.render();
```

### Dekorator w akcji

Na frontendzie wzorzec Dekorator moÅ¼e mieÄ‡ kilka znaczeÅ„. We frameworkach, ktÃ³re przede wszystkim stawiajÄ… na klasy i obiekty, wzorzec moÅ¼na wykorzystywaÄ‡ korzystajÄ…c z dekoratorÃ³w TypeScripta (np. dekorator ==@Injectable== - sprawienie, aby serwis angularowy byÅ‚ zauwaÅ¼alny przez system do wstrzykiwania zaleÅ¼noÅ›ci). Z kolei w tych frameworkach, ktÃ³re stawiajÄ… na bardziej funkcyjne podejÅ›cie, dekoratorami bÄ™dÄ… ==komponenty wyÅ¼szego rzÄ™du (Higher-Order Components)== lub ==uniwersalne hooki== - sÄ… to rozszerzenia istniejÄ…cych komponentÃ³w, ktÃ³re nie modyfikujÄ… ich podstawowego dziaÅ‚ania.

HOC
https://playcode.io/2191521
```typescript
const withDataFetching = (endpoint: string) => (WrappedComponent: React.ComponentType<any>) => {

Â  return function WithDataFetchingComponent(props) {

Â  Â  const [data, setData] = useState(null);
Â  Â  const [loading, setLoading] = useState(true);
Â  Â  useEffect(() => {
Â  Â  Â  fetch(endpoint)
Â  Â  Â  Â  .then(res => res.json())
Â  Â  Â  Â  .then(data => {
Â  Â  Â  Â  Â  setData(data);
Â  Â  Â  Â  Â  setLoading(false);
Â  Â  Â  Â  });
Â  Â  }, []);

Â  Â  return (
Â  Â  Â  <WrappedComponent
Â  Â  Â  Â  data={data}
Â  Â  Â  Â  loading={loading}
Â  Â  Â  Â  {...props}
Â  Â  Â  />
Â  Â  );
Â  };
};

// UÅ¼ycie
const UserList = ({ data, loading }) => {
Â  if (loading) return <div>Loading...</div>;
Â  return <ul>{data.map(user => <li key={user.id}>{user.name}</li>)}</ul>;
};

const UserListWithData = withDataFetching('/api/users')(UserList);
```

![[decorator-diagram.png]]