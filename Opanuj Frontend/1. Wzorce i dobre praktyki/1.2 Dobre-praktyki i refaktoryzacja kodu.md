
## Wprowadzenie

Jako programiÅ›ci czÄ™sto zmagamy siÄ™ z wyzwaniami utrzymania i rozwoju ==kodu, ktÃ³ry musi pozostaÄ‡ czytelny, Å‚atwy do zrozumienia i gotowy na zmiany==. W tej lekcji przybliÅ¼ymy ci zasady i podejÅ›cia, ktÃ³re pomogÄ… ci osiÄ…gnÄ…Ä‡ zaÅ‚oÅ¼ony cel.

Rozpoczniemy od zasady #DRY, czyli "==Donâ€™t Repeat Yourself==," ktÃ³ra ma na celu eliminowanie zbÄ™dnych powtÃ³rzeÅ„ kodu i budowanie rozwiÄ…zaÅ„ wielokrotnego uÅ¼ytku. NastÄ™pnie przyjrzymy siÄ™ piÄ™ciu zasadom ==#SOLID==, ktÃ³re wskazujÄ…, jak projektowaÄ‡ kod, aby byÅ‚ Å‚atwy w rozszerzaniu, ale odporny na zmiany, ktÃ³re mogÅ‚yby powodowaÄ‡ nieoczekiwane problemy. Z kolei  ==#CUPID== to zestaw mniej sztywnych wytycznych, ktÃ³re pozwolÄ… ci oceniÄ‡ jakoÅ›Ä‡ kodu pod kÄ…tem jego prostoty, przewidywalnoÅ›ci i zgodnoÅ›ci z ekosystemem.

Dowiesz siÄ™ rÃ³wnieÅ¼, kiedy warto siÄ™gaÄ‡ po zaawansowanÄ… refaktoryzacjÄ™, a kiedy wystarczy maÅ‚a zmiana na poziomie komponentÃ³w.

### Klasyczne praktyki czystego kodu - DRY, SOLID, CUPID


**#DRY**, czyli Dont Repeat Yourself to jedna z najbardziej popularnych rekomendacji w Å›wiecie programowania.

W zaÅ‚oÅ¼eniu jej przesÅ‚anie jest jak najbardziej rozsÄ…dne - unikaj powtÃ³rzeÅ„, buduj moÅ¼liwe do ponownego uÅ¼ycia funkcje, moduÅ‚y i biblioteki, oszczÄ™dzaj czas wprowadzajÄ…c zmiany tylko w jednym miejscu. W przypadku prostych projektÃ³w to powinno zdecydowanie wystarczyÄ‡.

W praktyce okazuje siÄ™ jednak, Å¼e do DRY powinniÅ›my podchodziÄ‡ pragmatycznie. Okazjonalne powielenie fragmentu kodu nie jest natychmiastowym przepisem na poraÅ¼kÄ™, a sposobem na unikanie niepotrzebnych powiÄ…zaÅ„ i tzw. ==â€œcouplinguâ€==. Zdarza siÄ™, Å¼e powtÃ³rzony w dwÃ³ch miejscach fragment kodu tylko przez chwilÄ™ pozostaje identyczny, a po chwili jeden z wariantÃ³w zaczyna ewoluowaÄ‡ w nowym kierunku. Budowanie abstrakcji i gotowych na wszystkie przyszÅ‚e rozszerzenia moduÅ‚Ã³w nie zawsze jest rozwiÄ…zaniem optymalnym.

DRY moÅ¼na teÅ¼ wprowadzaÄ‡Â stopniowo. Nie zawsze trzeba zaczynaÄ‡ od budowania prawdziwie reuÅ¼ywalnej, moÅ¼liwej do pobrania biblioteki, ktÃ³rÄ… umieÅ›cimy na zewnÄ…trz projektu. JeÅ›li algorytm w projekcie powtarza siÄ™ dwa razy, to moÅ¼na zaczÄ…Ä‡ od przesuniÄ™cia go do dedykowanego moduÅ‚u, ktÃ³ry nastÄ™pnie dwukrotnie zaimportujemy. OszczÄ™dzimy czas, unikniemy duplikacji i zyskamy moment na lepszÄ… ocenÄ™ sytuacji.

==**#SOLID**== to z kolei zestaw piÄ™ciu zasad projektowania oprogramowania, ktÃ³re mÃ³wiÄ… o tym, Å¼e:
- Funkcja lub moduÅ‚ powinny realizowaÄ‡Â jedno zadanie (==**S**ingle Responsibility Principle==)
- Kod powinien byÄ‡Â otwarty na rozszerzenia i zamkniÄ™ty na zmiany 
  (==**O**pen-Closed Principle==)
- Wymiana mniejszych fragmentÃ³w aplikacji nie powinna wymuszaÄ‡ aktualizacji caÅ‚ej architektury (==**L**iskov Substitution Principle==)
- Zamiast jednego ogÃ³lnego interfejsu stosuj kilka niezaleÅ¼nych od siebie (**==I**nterface Segregation Principle==)
- ZewnÄ™trzne zaleÅ¼noÅ›ci powinny byÄ‡ luÅºno powiÄ…zane z konsumentami i gotowe na wymianÄ™ (**==D**ependency Inversion Principle==)

![[Pasted image 20241213085545.png]]
O reguÅ‚ach SOLID napisano juÅ¼ dziesiÄ…tki artykuÅ‚Ã³w i zakÅ‚adamy, Å¼e prawdopodobnie nie spotykasz siÄ™ z nimi po raz pierwszy w naszym kursie. Aby jednak sprawdziÄ‡, czy na pewno rozumiesz ich dziaÅ‚anie, Ä‡wiczenia na koÅ„cu tej lekcji pozwolÄ… ci przetestowaÄ‡ frontendowy SOLID w praktyce.

JeÅ›li reguÅ‚y **SOLID** uwaÅ¼asz za maÅ‚o przekonujÄ…ce lub nie do koÅ„ca odpowiadajÄ…ce twoim codziennym zadaniom, przyjrzyj siÄ™Â bliÅ¼ej podejÅ›ciu ==[**CUPID**](https://dannorth.net/cupid-for-joyful-coding/)===, ktÃ³re stawia na pierwszym miejscu przyjemnoÅ›Ä‡ z kodowania.

W przeciwieÅ„stwie do mocno okreÅ›lonych zasad SOLIDnej piÄ…tki, CUPID to przede wszystkim ==â€œdoÅ›wiadczeniaâ€ i kierunek, w ktÃ³rym moÅ¼esz stopniowo podÄ…Å¼aÄ‡ refaktoryzujÄ…c twÃ³j kod.

Autor podejÅ›cia #CUPID, Dan North, wyjaÅ›nia to w ten sposÃ³b:

> â€œProperties define a goal or centre to move towards. Your code is only closer to or further from the centre, and there is always a clear direction of travel. You can use properties as a lens or filter to assess your code and you can decide which ones to address next.â€ - Dan North

Zobacz czym charakteryzuje siÄ™ kod zgodny z #CUPID:

- ==Composable== - Kod Å‚atwy do wykorzystania ponownie, z okreÅ›lonym przeznaczeniem, kod powinien byÄ‡Â jakÂ klockiÂ LEGO: 
	- Å‚atwyÂ do Å‚Ä…czenia zÂ innymi komponentami
	- JasnoÂ zdefiniowane interfejsy
	- MoÅ¼liwoÅ›Ä‡ wielokrotnego uÅ¼ycia
    
- [Unix Philosophy](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html) - Kod opierajÄ…cy siÄ™ o maÅ‚e, precyzyjne, Å‚Ä…czÄ…ce siÄ™ ze sobÄ… moduÅ‚y, czyli
	- RobiÄ‡ jednÄ… rzeczÂ dobrze
	- WspÃ³Å‚pracowaÄ‡ zÂ innymi poprzez proste interfejsy
	- ObsÅ‚ugiwaÄ‡ strumienie tekstu jakoÂ uniwersalny interfejs
    
- ==Predictable== - Kod robiÄ…cy to, co na pierwszy rzut oka sugeruje jego architektura, kod powinien:
	-  ZachowywaÄ‡ siÄ™Â wÂ przewidywalny sposÃ³b
	- ByÄ‡ spÃ³jny wÂ nazewnictwie iÂ strukturze
	- UnikaÄ‡ ukrytych efektÃ³w ubocznych
    
- ==Idiomatic== - Kod zgodny z ekosystemem i tradycjÄ…, w ktÃ³rej powstaÅ‚, kod powinien:
	- WykorzystywaÄ‡ konwencje typoweÂ dla danego jÄ™zyka/platformy
	- ByÄ‡ napisany w sposÃ³bÂ naturalny i zrozumiaÅ‚y
	- StosowaÄ‡ sprawdzone wzorce
    
- ==Domain-based== - Kod korzystajÄ…cy z terminologii problemu, ktÃ³ry rozwiÄ…zuje, kod powinien:
	- OdzwierciedlaÄ‡ jÄ™zykÂ iÂ koncepcjeÂ domeny biznesowej
	- ByÄ‡ zorganizowany wokÃ³Å‚ modeluÂ domeny
	- UÅ¼ywaÄ‡ terminologii zrozumiaÅ‚ej dla ekspertÃ³w domenowych

![[Pasted image 20241213090210.png]]
CUPID kÅ‚adzie naciskÂ na ==pragmatyczne podejÅ›cie== do pisania kodu, ktÃ³ryÂ jest przyjemny w utrzymaniu i rozwoju, wÂ przeciwieÅ„stwieÂ do bardziej rygorystycznych zasad SOLID.

W przeciwieÅ„stwie do reguÅ‚ SOLID, CUPID nie skupia siÄ™ na czarno-biaÅ‚ym okreÅ›leniu jakoÅ›ci kodu wzglÄ™dem konkretnych praktyk. Jest to raczej pragmatyczny zestaw rekomendacji i celÃ³w, ktÃ³re powinniÅ›my sobie stawiaÄ‡ budujÄ…c moÅ¼liwe do utrzymania oprogramowanie, ktÃ³ry zrozumie inny programista na podobnym do nas stanowisku.

Podobnie jak w przypadku reguÅ‚ SOLID, zalecenia CUPID przetestujemy w sekcji Ä‡wiczeÅ„ do tej lekcji.

### Zastosowanie na frontendzie

Wobec praktyk takich jak SOLID czy CUPID czasami pojawia siÄ™ zarzut, Å¼e ich obiektowe (?) pochodzenie nie do koÅ„ca Å‚Ä…czy siÄ™ z mocno funkcyjnym frontendem. Ile w tym prawdy?

**Komponenty wysokiej jakoÅ›ci**

Zacznijmy od komponentÃ³w, czyli podstawowej skÅ‚adowej wspÃ³Å‚czesnych interfejsÃ³w uÅ¼ytkownika. W ich przypadku zdecydowanie powinniÅ›my stosowaÄ‡Â reguÅ‚Ä™ â€œrealizacji jednego zadaniaâ€ oraz kompozycji w wiÄ™kszÄ… caÅ‚oÅ›Ä‡. Trudno wyobraziÄ‡ sobie profesjonalnÄ… aplikacjÄ™ z jednym komponentem, ktÃ³ry odpowiada za synchronizacjÄ™ caÅ‚ego interfejsu uÅ¼ytkownika. Nasz UI zwykle rozbijamy na mniejsze, moÅ¼liwe do wymiany elementy. Zazwyczaj staramy siÄ™ teÅ¼ odwzorowaÄ‡ nazewnictwo domeny, w ktÃ³rej te komponenty dziaÅ‚ajÄ….

To nic innego jak trzy rekomendacje w jednym:

- Single Responsibility Principle (SOLID)
- Composability (CUPID)
- Domain-based naming (CUPID)
    
![[Pasted image 20240307145836.png]]
Planowanie nawet najprostszej struktury aplikacji to Ä‡wiczenie, na ktÃ³re warto zdecydowaÄ‡ siÄ™ na poczÄ…tkowych etapach projektu. Pozwoli nam to okreÅ›liÄ‡ konsekwencje takiego, a nie innego ukÅ‚adu komponentÃ³w. Odkryjemy rÃ³wnieÅ¼ wymagania zwiÄ…zane ze stanem i przepÅ‚ywem danych, a caÅ‚y zespÃ³Å‚ uzyska wspÃ³lne zrozumienie decyzji wpÅ‚ywajÄ…cych na skuteczne realizowanie projektu. TÄ™ tematykÄ™ pogÅ‚Ä™bimy w ostatnim module poÅ›wiÄ™conym architekturze na frontendzie, a juÅ¼ w kolejnych lekcjach zobaczysz rÃ³Å¼ne podejÅ›cia do zarzÄ…dzania stanem, wynikajÄ…ce wprost z ukÅ‚adu komponentÃ³w wzglÄ™dem siebie.

A jeÅ›li budujemy komunikacjÄ™ z API? Czy naprawdÄ™ biblioteki takie jak _axios_ lub _superagent_ powinny na nas wymuszaÄ‡ zwiÄ…zanie siÄ™ z nimi juÅ¼ na zawsze? Co w przypadku natywnego API _fetch_, ktÃ³re w pewnym momencie zaczÄ™Å‚o byÄ‡Â obowiÄ…zujÄ…cym standardem? To wÅ‚aÅ›nie czysty kod i wspomniane wyÅ¼ej wzorce decydujÄ… o Å‚atwoÅ›ci migracji do nowych standardÃ³w.

JeÅ›li nasze komponenty bÄ™dÄ… mocno powiÄ…zane z zewnÄ™trznymi zaleÅ¼noÅ›ciami, takimi jak konkretna biblioteka http, to przy jej ewentualnej aktualizacji bÄ™dziemy mieÄ‡ do wykonania mnÃ³stwo pracy. ==ReguÅ‚a odwrÃ³cenia zaleÅ¼noÅ›ci mÃ³wi, Å¼e tego typu zaleÅ¼noÅ›ci powinny byÄ‡ luÅºno powiÄ…zane z corem aplikacji i dostarczane z zewnÄ…trz==.

W przypadku Angulara, zÅ‚amaniem tej zasady byÅ‚oby tworzenie instancji klienta http wewnÄ…trz komponentu:

```typescript
class MyComponent {

  private http: HttpService = new AxiosService(); // zÅ‚amanie Dependency Inversion

}
```

Zamiast tego, moÅ¼emy polegaÄ‡ na wbudow`anym systemie ==Dependency Injection==, ktÃ³ry umoÅ¼liwia rozÅ‚Ä…czenie deklarowania zaleÅ¼noÅ›ci i korzystania z nich wewnÄ…trz komponentÃ³w. 


```typescript
class MyComponent {

  constructor(private http: HttpService) { ... } // zaleÅ¼noÅ›Ä‡ wstrzykiwana przez konstruktor

}

// --- Tworzenie nowej instancji wraz z zastosowaniem Dependency Injection:

const cmp = new MyComponent(new AxiosService()); // zazwyczaj realizowane przez framework
```

W przeciwieÅ„stwie do Angulara, React nie dostarcza natywnego systemu Dependency Injection, ale podobnÄ… separacjÄ™ komponentÃ³w i zaleÅ¼noÅ›ci moÅ¼emy osiÄ…gnÄ…Ä‡ przez wÅ‚asne hooki.

W poniÅ¼szym przykÅ‚adzie komponent _ArticlesList_ korzysta z hooka _useArticlesClient_ ktÃ³ry enkapsuluje (ukrywa) szczegÃ³Å‚y implementacyjne pobierania danych. DziÄ™ki temu zarÃ³wno sam hook moÅ¼na wykorzystaÄ‡ ponownie w innym komponencie, jak i sam komponent moÅ¼na w razie potrzeby Å‚atwo przepiÄ…Ä‡ na innÄ… bibliotekÄ™ http.
(==Dependency Inversion Principle==)
```typescript
import { ArticlePreview } from './ArticlePreview';
import { useArticlesClient } from './useArticlesClient';

export function ArticlesList() {
  const { articles, loading, error } = useArticlesClient();

  return (
    <>
      <h1 className="font-bold text-xl mb-4 text-gray-800">Articles</h1>
      {loading && <div>Loading...</div>}
      {error && <div>{error}</div>}
      <div className="flex flex-col space-y-2">
        {articles.map((article) => (
          <ArticlePreview key={article.id} {...article} />
        ))}
      </div>
    </>
  );
}
```

Wspomniany hook zobaczysz na przykÅ‚adzie poniÅ¼ej:

```typescript
import { useEffect, useState } from 'react';
import axios from 'axios';
import { Article, ArticleResponse } from './types';

export function useArticlesClient() {
  const [articles, setArticles] = useState<Article[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>();

  useEffect(() => {
    setLoading(true);
    axios
      .get<ArticleResponse>(
        'http://localhost:3000/api/data/articles?timeout=2000'
      )
      .then(({ data: { articles } }) => {
        setArticles(articles);
      })
      .catch((error) => {
        setError('Cannot fetch articles!');
        console.error(error);
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  return { articles, loading, error };
}
```

DodatkowÄ… zaletÄ… rozdzielania logiki biznesowej (hook) od warstwy widoku (komponent) jest refaktoryzacja kodu w kierunku jego testowalnoÅ›ci. W ten wÄ…tek wejdziemy gÅ‚Ä™biej w drugim module, natomiast juÅ¼ teraz moÅ¼esz zauwaÅ¼yÄ‡ korzyÅ›ci budowania funkcji, ktÃ³re nie sÄ… Å›ciÅ›le zwiÄ…zane z konkretnym komponentem. W przypadku testowania pozwoli ci to unikaÄ‡ zÅ‚oÅ¼onej konfiguracji i inicjalizacji komponentÃ³w w testach, skupiajÄ…c siÄ™ na tym, co istotne z punktu widzenia wymagaÅ„ biznesowych.

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module1/lesson1/react-hooks_**.

**Komponent otwarty i zamkniÄ™ty (jednoczeÅ›nie)**

W teoretycznej czÄ™Å›ci praktyk SOLID czytamy, Å¼e zgodnoÅ›Ä‡ z ===Open-Closed Principle== to tworzenie kodu:

- otwartego na rozszerzenia
- zamkniÄ™tego na zmiany

W jaki sposÃ³b jeden komponent moÅ¼e realizowaÄ‡ oba te zaÅ‚oÅ¼enia jednoczeÅ›nie? Czy nowe wymagania biznesowe nie powinny kaÅ¼dorazowo zmuszaÄ‡ programisty do modyfikacji wczeÅ›niej napisanych linijek kodu?

Okazuje siÄ™, Å¼e istniejÄ… techniki Å‚Ä…czÄ…ce te pozornie sprzeczne wymagania. Zobacz, jak technika ==#render_props pozwala zaimplementowaÄ‡ rekomendacjÄ™ Open-Closed Principle==:

==Render props== to jedna z wielu technik implementacji ==Open-Closed Principle== w praktyce. Jak rozpoznaÄ‡, kiedy ta praktyka przyda siÄ™ w twoich projektach? Zawsze wtedy, kiedy ==w projekcie dana nowoÅ›Ä‡ lub rozszerzenie ma zaleÅ¼noÅ›Ä‡ czasowÄ…==, rozwaÅ¼ zastosowanie tej zasady. PrzykÅ‚adowo:
- â€œDzisiaj dodajemy 5 filtrÃ³w do tabeli, ale w kolejnych kwartaÅ‚ach bÄ™dÄ… nowe"
- â€œDzisiaj dodajemy 3 widgety, ale w przyszÅ‚oÅ›ci musi byÄ‡ ich wiÄ™cejâ€
- â€œDzisiaj na dashboardzie sÄ… 4 typy wykresÃ³w, ale chcemy wspieraÄ‡ 8â€

W kaÅ¼dym z tych scenariuszy element â€œOpenâ€ dotyczy pozostawania otwartym na nowoÅ›ci, a â€œClosedâ€ dotyczy spÃ³jnego mechanizmu, ktÃ³re zaimplementujesz na samym poczÄ…tku. ZamkniÄ™cie danej funkcjonalnoÅ›ci moÅ¼e chociaÅ¼by polegaÄ‡ na zdefiniowaniu jednego interfejsu, ktÃ³rego bÄ™dÄ… musiaÅ‚y siÄ™ trzymaÄ‡ wszystkie kolejne rozszerzenia:

```typescript
// Format danych w tabeli
interface TableRow {
  name: string;
  age: number;
  city: string;
}

// Generyczny interfejs do obsÅ‚ugi filtrowania danych
interface TableFilter<T extends TableRow> {
  apply(data: T[]): T[];
}

// Implementacja filtrowania po nazwie
class NameFilter implements TableFilter<TableRow> {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  apply(data: TableRow[]): TableRow[] {
    return data.filter((row) => row.name === this.name);
  }
}

// Implementacja filtrowania po wieku
class AgeFilter implements TableFilter<TableRow> {
  private age: number;

  constructor(age: number) {
    this.age = age;
  }

  apply(data: TableRow[]): TableRow[] {
    return data.filter((row) => row.age === this.age);
  }
}

// PrzykÅ‚adowe dane do tabeli
const data: TableRow[] = [
  {name: "Alice", age: 30, city: "New York"},
  {name: "Bob", age: 25, city: "San Francisco"},
  {name: "Alice", age: 29, city: "Los Angeles"},
];

// Open - zestaw filtrÃ³w jest otwarty na rozszerzenia i jest to zadanie niskiego ryzyka
const filters: TableFilter<TableRow>[] = [
  new NameFilter("Alice"),
  new AgeFilter(30),
];

// Closed - jednolita obsÅ‚uga filtrowania - warte przetestowania i zabezpieczenia
function applyFilters<T extends TableRow>(
  data: T[],
  filters: TableFilter<T>[]
): T[] {
  return filters.reduce(
    (filteredData, filter) => filter.apply(filteredData),
    data
  );
}

let filteredData = applyFilters(data, filters);
console.log(filteredData);
```

https://playcode.io/2190149

W obu przypadkach _TableFilter_ wprowadza reguÅ‚Ä™ - jeÅ›li chcesz wspieraÄ‡ nowy typ filtrowania danych, zaimplementuj klasÄ™ z funkcjÄ… â€œapplyâ€, ktÃ³ra przyjmie pewien zestaw danych i odpowiednio go ograniczy. Od strony konsumenta filtrÃ³w wiesz, Å¼e caÅ‚y wysiÅ‚ek sprowadzi siÄ™ wtedy do jednorazowej implementacji funkcji â€œapplyFiltersâ€, ktÃ³ra przetworzy bazowy zestaw danych i konfiguracjÄ™ filtrÃ³w. Takie podejÅ›cie pozwoli ci z Å‚atwoÅ›ciÄ… rozszerzaÄ‡ kod i udostÄ™pniaÄ‡ go innym osobom.

NajwaÅ¼niejszy element tej rekomendacji dotyczy okreÅ›lenia tego, jakie fragmenty interfejsu uÅ¼ytkownika, moduÅ‚u lub komponentu powinny byÄ‡ ukryte przed Å›wiatem zewnÄ™trznym, a jakie moÅ¼na konfigurowaÄ‡ w dowolny sposÃ³b. PiszÄ…c nasz kod w ten sposÃ³b minimalizujemy ryzyko wprowadzania bÅ‚Ä™dÃ³w przy jednoczesnym zachowaniu oczekiwanej elastycznoÅ›ci. Win-win!
**Inspiracje systemami Unix**

CUPID wspomina o rozwijaniu kodu zgodnie z tzw. filozofiÄ… Unixa (Unix Philosophy). W systemach UNIXowych promowane sÄ… maÅ‚e programy (awk, grep, tr, itd.), ktÃ³re przy pomocy operatora _pipe_ mogÄ… przekazywaÄ‡ sobie nawzajem dane i Å‚Ä…czyÄ‡ siÄ™ w realizacji wiÄ™kszego zadania:

```bash
echo "1 4 6 8 10" | 
  tr ' ' '\n' |                  # PodziaÅ‚ na wiele wierszy
  awk '{print $1*2}' |           # MnoÅ¼enie przez 2
  awk '$1<=10' |                 # Filtrowanie
  awk '{sum+=$1} END {print sum}' # Sumowanie
```

NaprawdÄ™ warto zastanowiÄ‡ siÄ™ przez chwilÄ™ jak eleganckie jest to rozwiÄ…zanie. NarzÄ™dzia majÄ… Å›ciÅ›le okreÅ›lonÄ… rolÄ™, muszÄ… byÄ‡ odpowiednio elastyczne i otwarte na rÃ³Å¼ne konteksty uÅ¼ycia, a wymiana lub ulepszenie jednego z nich nie zmusza nas do modyfikacji reszty (im mniej kodu musimy zmieniaÄ‡, tym mniejsza szansa na wprowadzenie potencjalnych bÅ‚Ä™dÃ³w).

Jak moÅ¼emy siÄ™ inspirowaÄ‡ ==Unix Philosophy na frontendzie? Zamiast imperatywnych poleceÅ„ opisywanych krok po kroku (wyraÅ¼enia warunkowe, pÄ™tle for, etc.), na frontendzie przyjÄ™tÄ…Â konwencjÄ… jest korzystanie z mikro-narzÄ™dzi i funkcji wyÅ¼szego rzÄ™du (_map, filter, reduce_), ktÃ³re moÅ¼emy ze sobÄ… Å‚Ä…czyÄ‡==.

DziÄ™ki temu z kodu o takim ksztaÅ‚cieâ€¦

```javascript
const numbers = [1, 4, 6, 8, 10];
let sum = 0;

for (let i = 0; i < numbers.length; i++) {
    const doubled = numbers[i] * 2;
    if (doubled <= 10) {
        sum += doubled;
    }
}

console.log(sum);
```

â€¦moÅ¼emy przejÅ›Ä‡ na elegancki, deklaratywny Å‚aÅ„cuch moÅ¼liwych do Å‚Ä…czenia funkcji:

```javascript
const numbers = [1, 4, 6, 8, 10];

const result = numbers
  .map(num => num * 2)
  .filter(num => num <= 10)
  .reduce((sum, num) => sum + num, 0);

console.log(result);
```

PiszÄ…c kod w ten sposÃ³b, detale takie jak indeksy, warunki zatrzymania funkcji czy zmienne pomocnicze nie sÄ… nam potrzebne. Znowu - im mniejsza zÅ‚oÅ¼onoÅ›Ä‡ kodu, tym mniej okazji do popeÅ‚niania bÅ‚Ä™dÃ³w.

Nie zawsze uzyskamy w ten sposÃ³b kod bardziej wydajny (liczba wykonaÅ„ pÄ™tli siÄ™Â zwiÄ™ksza), ale czÄ™sto zdecydowanie Å‚atwiejszy w utrzymaniu.

KorzyÅ›ci wynikajÄ…ce ze stosowania praktyk takich jak SOLID czy CUPID docenia z biegiem czasu niemal kaÅ¼dy programista. ChociaÅ¼ nie sÄ… to zasady wymuszane przez Å›rodowisko programistyczne, a ich zÅ‚amanie nie grozi odebraniem licencji na programowanie, przyjmuje siÄ™ je za wskaÅºnik oprogramowania wysokiej jakoÅ›ci.



https://playcode.io/2190149

