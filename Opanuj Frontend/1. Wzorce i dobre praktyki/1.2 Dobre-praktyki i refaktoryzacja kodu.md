## Wprowadzenie

Jako programiÅ›ci czÄ™sto zmagamy siÄ™ z wyzwaniami utrzymania i rozwoju kodu, ktÃ³ry musi pozostaÄ‡ czytelny, Å‚atwy do zrozumienia i gotowy na zmiany. W tej lekcji przybliÅ¼ymy ci zasady i podejÅ›cia, ktÃ³re pomogÄ… ci osiÄ…gnÄ…Ä‡ zaÅ‚oÅ¼ony cel.

Rozpoczniemy od zasady DRY, czyli "Donâ€™t Repeat Yourself," ktÃ³ra ma na celu eliminowanie zbÄ™dnych powtÃ³rzeÅ„ kodu i budowanie rozwiÄ…zaÅ„ wielokrotnego uÅ¼ytku. NastÄ™pnie przyjrzymy siÄ™ piÄ™ciu zasadom SOLID, ktÃ³re wskazujÄ…, jak projektowaÄ‡ kod, aby byÅ‚ Å‚atwy w rozszerzaniu, ale odporny na zmiany, ktÃ³re mogÅ‚yby powodowaÄ‡ nieoczekiwane problemy. Z kolei CUPID to zestaw mniej sztywnych wytycznych, ktÃ³re pozwolÄ… ci oceniÄ‡ jakoÅ›Ä‡ kodu pod kÄ…tem jego prostoty, przewidywalnoÅ›ci i zgodnoÅ›ci z ekosystemem.

Dowiesz siÄ™ rÃ³wnieÅ¼, kiedy warto siÄ™gaÄ‡ po zaawansowanÄ… refaktoryzacjÄ™, a kiedy wystarczy maÅ‚a zmiana na poziomie komponentÃ³w.

### Klasyczne praktyki czystego kodu - DRY, SOLID, CUPID

**DRY**, czyli â€œDonâ€™t Repeat Yourselfâ€ to jedna z najbardziej popularnych rekomendacji w Å›wiecie programowania.

W zaÅ‚oÅ¼eniu jej przesÅ‚anie jest jak najbardziej rozsÄ…dne - unikaj powtÃ³rzeÅ„, buduj moÅ¼liwe do ponownego uÅ¼ycia funkcje, moduÅ‚y i biblioteki, oszczÄ™dzaj czas wprowadzajÄ…c zmiany tylko w jednym miejscu. W przypadku prostych projektÃ³w to powinno zdecydowanie wystarczyÄ‡.

W praktyce okazuje siÄ™ jednak, Å¼e do DRY powinniÅ›my podchodziÄ‡ pragmatycznie. Okazjonalne powielenie fragmentu kodu nie jest natychmiastowym przepisem na poraÅ¼kÄ™, a sposobem na unikanie niepotrzebnych powiÄ…zaÅ„ i tzw. â€œcouplinguâ€. Zdarza siÄ™, Å¼e powtÃ³rzony w dwÃ³ch miejscach fragment kodu tylko przez chwilÄ™ pozostaje identyczny, a po chwili jeden z wariantÃ³w zaczyna ewoluowaÄ‡ w nowym kierunku. Budowanie abstrakcji i gotowych na wszystkie przyszÅ‚e rozszerzenia moduÅ‚Ã³w nie zawsze jest rozwiÄ…zaniem optymalnym.

DRY moÅ¼na teÅ¼ wprowadzaÄ‡Â stopniowo. Nie zawsze trzeba zaczynaÄ‡ od budowania prawdziwie reuÅ¼ywalnej, moÅ¼liwej do pobrania biblioteki, ktÃ³rÄ… umieÅ›cimy na zewnÄ…trz projektu. JeÅ›li algorytm w projekcie powtarza siÄ™ dwa razy, to moÅ¼na zaczÄ…Ä‡ od przesuniÄ™cia go do dedykowanego moduÅ‚u, ktÃ³ry nastÄ™pnie dwukrotnie zaimportujemy. OszczÄ™dzimy czas, unikniemy duplikacji i zyskamy moment na lepszÄ… ocenÄ™ sytuacji.

**SOLID** to z kolei zestaw piÄ™ciu zasad projektowania oprogramowania, ktÃ³re mÃ³wiÄ… o tym, Å¼e:

- Funkcja lub moduÅ‚ powinny realizowaÄ‡Â jedno zadanie (Single Responsibility Principle    
- Kod powinien byÄ‡Â otwarty na rozszerzenia i zamkniÄ™ty na zmiany (Open-Closed Principle)
- Wymiana mniejszych fragmentÃ³w aplikacji nie powinna wymuszaÄ‡ aktualizacji caÅ‚ej architektury (Liskov Substitution Principle)
- Zamiast jednego ogÃ³lnego interfejsu stosuj kilka niezaleÅ¼nych od siebie (Interface Segregation Principle)
- ZewnÄ™trzne zaleÅ¼noÅ›ci powinny byÄ‡ luÅºno powiÄ…zane z konsumentami i gotowe na wymianÄ™ (Dependency Inversion Principle)
![[Pasted image 20241213085545.png]]
O reguÅ‚ach SOLID napisano juÅ¼ dziesiÄ…tki artykuÅ‚Ã³w i zakÅ‚adamy, Å¼e prawdopodobnie nie spotykasz siÄ™ z nimi po raz pierwszy w naszym kursie. Aby jednak sprawdziÄ‡, czy na pewno rozumiesz ich dziaÅ‚anie, Ä‡wiczenia na koÅ„cu tej lekcji pozwolÄ… ci przetestowaÄ‡ frontendowy SOLID w praktyce.

JeÅ›li reguÅ‚y **SOLID** uwaÅ¼asz za maÅ‚o przekonujÄ…ce lub nie do koÅ„ca odpowiadajÄ…ce twoim codziennym zadaniom, przyjrzyj siÄ™Â bliÅ¼ej podejÅ›ciu [**CUPID**](https://dannorth.net/cupid-for-joyful-coding/), ktÃ³re stawia na pierwszym miejscu przyjemnoÅ›Ä‡ z kodowania.

W przeciwieÅ„stwie do mocno okreÅ›lonych zasad SOLIDnej piÄ…tki, CUPID to przede wszystkim â€œdoÅ›wiadczeniaâ€ i kierunek, w ktÃ³rym moÅ¼esz stopniowo podÄ…Å¼aÄ‡ refaktoryzujÄ…c twÃ³j kod.

Autor podejÅ›cia CUPID, Dan North, wyjaÅ›nia to w ten sposÃ³b:

> â€œProperties define a goal or centre to move towards. Your code is only closer to or further from the centre, and there is always a clear direction of travel. You can use properties as a lens or filter to assess your code and you can decide which ones to address next.â€ - Dan North

Zobacz czym charakteryzuje siÄ™ kod zgodny z CUPID:

- Composable - Kod Å‚atwy do wykorzystania ponownie, z okreÅ›lonym przeznaczeniem
- [Unix Philosophy](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html) - Kod opierajÄ…cy siÄ™ o maÅ‚e, precyzyjne, Å‚Ä…czÄ…ce siÄ™ ze sobÄ… moduÅ‚y
- Predictable - Kod robiÄ…cy to, co na pierwszy rzut oka sugeruje jego architektura
- Idiomatic - Kod zgodny z ekosystemem i tradycjÄ…, w ktÃ³rej powstaÅ‚
- Domain-based - Kod korzystajÄ…cy z terminologii problemu, ktÃ³ry rozwiÄ…zuje
    
![[Pasted image 20241213090210 1.png]]
W przeciwieÅ„stwie do reguÅ‚ SOLID, CUPID nie skupia siÄ™ na czarno-biaÅ‚ym okreÅ›leniu jakoÅ›ci kodu wzglÄ™dem konkretnych praktyk. Jest to raczej pragmatyczny zestaw rekomendacji i celÃ³w, ktÃ³re powinniÅ›my sobie stawiaÄ‡ budujÄ…c moÅ¼liwe do utrzymania oprogramowanie, ktÃ³ry zrozumie inny programista na podobnym do nas stanowisku.

Podobnie jak w przypadku reguÅ‚ SOLID, zalecenia CUPID przetestujemy w sekcji Ä‡wiczeÅ„ do tej lekcji.

### Zastosowanie na frontendzie

Wobec praktyk takich jak SOLID czy CUPID czasami pojawia siÄ™ zarzut, Å¼e ich obiektowe (?) pochodzenie nie do koÅ„ca Å‚Ä…czy siÄ™ z mocno funkcyjnym frontendem. Ile w tym prawdy?

**Komponenty wysokiej jakoÅ›ci**

Zacznijmy od komponentÃ³w, czyli podstawowej skÅ‚adowej wspÃ³Å‚czesnych interfejsÃ³w uÅ¼ytkownika. W ich przypadku zdecydowanie powinniÅ›my stosowaÄ‡Â reguÅ‚Ä™ â€œrealizacji jednego zadaniaâ€ oraz kompozycji w wiÄ™kszÄ… caÅ‚oÅ›Ä‡. Trudno wyobraziÄ‡ sobie profesjonalnÄ… aplikacjÄ™ z jednym komponentem, ktÃ³ry odpowiada za synchronizacjÄ™ caÅ‚ego interfejsu uÅ¼ytkownika. Nasz UI zwykle rozbijamy na mniejsze, moÅ¼liwe do wymiany elementy. Zazwyczaj staramy siÄ™ teÅ¼ odwzorowaÄ‡ nazewnictwo domeny, w ktÃ³rej te komponenty dziaÅ‚ajÄ….

To nic innego jak trzy rekomendacje w jednym:

- Single Responsibility Principle (SOLID)
- Composability (CUPID)
- Domain-based naming (CUPID)
    

Planowanie nawet najprostszej struktury aplikacji to Ä‡wiczenie, na ktÃ³re warto zdecydowaÄ‡ siÄ™ na poczÄ…tkowych etapach projektu. Pozwoli nam to okreÅ›liÄ‡ konsekwencje takiego, a nie innego ukÅ‚adu komponentÃ³w. Odkryjemy rÃ³wnieÅ¼ wymagania zwiÄ…zane ze stanem i przepÅ‚ywem danych, a caÅ‚y zespÃ³Å‚ uzyska wspÃ³lne zrozumienie decyzji wpÅ‚ywajÄ…cych na skuteczne realizowanie projektu. TÄ™ tematykÄ™ pogÅ‚Ä™bimy w ostatnim module poÅ›wiÄ™conym architekturze na frontendzie, a juÅ¼ w kolejnych lekcjach zobaczysz rÃ³Å¼ne podejÅ›cia do zarzÄ…dzania stanem, wynikajÄ…ce wprost z ukÅ‚adu komponentÃ³w wzglÄ™dem siebie.

A jeÅ›li budujemy komunikacjÄ™ z API? Czy naprawdÄ™ biblioteki takie jak _axios_ lub _superagent_ powinny na nas wymuszaÄ‡ zwiÄ…zanie siÄ™ z nimi juÅ¼ na zawsze? Co w przypadku natywnego API _fetch_, ktÃ³re w pewnym momencie zaczÄ™Å‚o byÄ‡Â obowiÄ…zujÄ…cym standardem? To wÅ‚aÅ›nie czysty kod i wspomniane wyÅ¼ej wzorce decydujÄ… o Å‚atwoÅ›ci migracji do nowych standardÃ³w.

JeÅ›li nasze komponenty bÄ™dÄ… mocno powiÄ…zane z zewnÄ™trznymi zaleÅ¼noÅ›ciami, takimi jak konkretna biblioteka http, to przy jej ewentualnej aktualizacji bÄ™dziemy mieÄ‡ do wykonania mnÃ³stwo pracy. ReguÅ‚a odwrÃ³cenia zaleÅ¼noÅ›ci mÃ³wi, Å¼e tego typu zaleÅ¼noÅ›ci powinny byÄ‡ luÅºno powiÄ…zane z corem aplikacji i dostarczane z zewnÄ…trz.

W przypadku Angulara, zÅ‚amaniem tej zasady byÅ‚oby tworzenie instancji klienta http wewnÄ…trz komponentu:

```typescript
class MyComponent {

  // ZÅ‚amanie Dependency Inversion - MyComponent staje siÄ™ mocno powiÄ…zany z AxiosService
  private http: HttpService = new AxiosService();

}
```

Zamiast tego, moÅ¼emy polegaÄ‡ na wbudowanym systemie Dependency Injection, ktÃ³ry umoÅ¼liwia rozÅ‚Ä…czenie deklarowania zaleÅ¼noÅ›ci i korzystania z nich wewnÄ…trz komponentÃ³w.

```typescript
class MyComponent {

  // MyComponent otrzyma instancjÄ™ HttpService - konfiguracja znajduje siÄ™ poza nim
  constructor(private http: HttpService) { ... }

}

// Tworzenie nowej instancji wraz z zastosowaniem Dependency Injection
// jest realizowane automatycznie na poziomie frameworka.
const cmp = new MyComponent(new AxiosService());
```

W przeciwieÅ„stwie do Angulara, React nie dostarcza natywnego systemu Dependency Injection, ale podobnÄ… separacjÄ™ komponentÃ³w i zaleÅ¼noÅ›ci moÅ¼emy osiÄ…gnÄ…Ä‡ przez wÅ‚asne hooki.

W poniÅ¼szym przykÅ‚adzie komponent _ArticlesList_ korzysta z hooka _useArticlesClient_ ktÃ³ry enkapsuluje (ukrywa) szczegÃ³Å‚y implementacyjne pobierania danych. DziÄ™ki temu zarÃ³wno sam hook moÅ¼na wykorzystaÄ‡ ponownie w innym komponencie, jak i sam komponent moÅ¼na w razie potrzeby Å‚atwo przepiÄ…Ä‡ na innÄ… bibliotekÄ™ http.

```typescript
import { ArticlePreview } from './ArticlePreview';
import { useArticlesClient } from './useArticlesClient';

export function ArticlesList() {
  const { articles, loading, error } = useArticlesClient();

  return (
    <>
      <h1 className="font-bold text-xl mb-4 text-gray-800">Articles</h1>
      {loading && <div>Loading...</div>}
      {error && <div>{error}</div>}
      <div className="flex flex-col space-y-2">
        {articles.map((article) => (
          <ArticlePreview key={article.id} {...article} />
        ))}
      </div>
    </>
  );
}
```

Wspomniany hook zobaczysz na przykÅ‚adzie poniÅ¼ej:

```typescript
import { useEffect, useState } from 'react';
import axios from 'axios';
import { Article, ArticleResponse } from './types';

export function useArticlesClient() {
  const [articles, setArticles] = useState<Article[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>();

  useEffect(() => {
    setLoading(true);
    axios
      .get<ArticleResponse>(
        'http://localhost:3000/api/data/articles?timeout=2000'
      )
      .then(({ data: { articles } }) => {
        setArticles(articles);
      })
      .catch((error) => {
        setError('Cannot fetch articles!');
        console.error(error);
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  return { articles, loading, error };
}
```

DodatkowÄ… zaletÄ… rozdzielania logiki biznesowej (hook) od warstwy widoku (komponent) jest refaktoryzacja kodu w kierunku jego testowalnoÅ›ci. W ten wÄ…tek wejdziemy gÅ‚Ä™biej w drugim module, natomiast juÅ¼ teraz moÅ¼esz zauwaÅ¼yÄ‡ korzyÅ›ci budowania funkcji, ktÃ³re nie sÄ… Å›ciÅ›le zwiÄ…zane z konkretnym komponentem. W przypadku testowania pozwoli ci to unikaÄ‡ zÅ‚oÅ¼onej konfiguracji i inicjalizacji komponentÃ³w w testach, skupiajÄ…c siÄ™ na tym, co istotne z punktu widzenia wymagaÅ„ biznesowych.

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module1/lesson1/react-hooks_**.

W przypadku Vue, odwrÃ³cenie zaleÅ¼noÅ›ci realizowane jest poprzez funkcje [_provide_ oraz _inject_](https://vuejs.org/guide/components/provide-inject) - pierwsza odpowiada za rejestracjÄ™ zaleÅ¼noÅ›ci w drzewie komponentÃ³w, a druga za wstrzykniÄ™cie jej w odpowiednie miejsce w komponencie potomnym:

```tsx
<script setup>
// Parent component
import { provide } from 'vue';

provide('httpClient', new AxiosService());
</script>
```

```tsx
<script setup>
// Child component
import { inject } from 'vue';

const httpClient = inject('httpClient'); // instancja AxiosService
</script>
```

ZastanawiajÄ…c siÄ™ nad takim sposobem przekazywania danych moÅ¼esz zapytaÄ‡:

> -A dlaczego nie przez propsy?

WyobraÅº sobie, Å¼e pomiÄ™dzy powyÅ¼szymi komponentami jest szeÅ›Ä‡, osiem lub dziesiÄ™Ä‡ dodatkowych warstw. W takim scenariuszu kaÅ¼dÄ… porcjÄ™ danych musielibyÅ›my przekazaÄ‡ z wykorzystaniem tzw. _prop drillingu_, czyli â€œprzewiercania siÄ™â€ przez kolejne warstwy w drzewie komponentÃ³w (wiÄ™cej o tym problemie w kolejnych lekcjach). DziÄ™ki wstrzykiwaniu zaleÅ¼noÅ›ci, pracÄ™ wykonuje za nas framework, a funkcje provide/inject pozwalajÄ… uniknÄ…Ä‡ powtÃ³rzeÅ„.

JeÅ›li zajdzie potrzeba wymiany Axiosa na innego klienta HTTP, caÅ‚Ä… operacjÄ™ moÅ¼emy przeprowadziÄ‡ na gÃ³rze drzewa komponentÃ³w. Przy zachowaniu tego samego interfejsu dostÄ™pnych metod, komponenty potomne mogÄ… zostaÄ‡ nienaruszone. WrÃ³cimy do tego tematu w kolejnych lekcjach.

W kaÅ¼dym z trzech opisywanych frameworkÃ³w szczegÃ³Å‚y implementacyjne siÄ™ rÃ³Å¼niÄ…, ale koÅ„cowy cel, czyli luÅºne powiÄ…zanie zaleÅ¼noÅ›ci z komponentami jest stosunkowo proste do osiÄ…gniÄ™cia.

**Komponent otwarty i zamkniÄ™ty (jednoczeÅ›nie)**

W teoretycznej czÄ™Å›ci praktyk SOLID czytamy, Å¼e zgodnoÅ›Ä‡ z Open-Closed Principle to tworzenie kodu:

- otwartego na rozszerzenia
    
- zamkniÄ™tego na zmiany
    

W jaki sposÃ³b jeden komponent moÅ¼e realizowaÄ‡ oba te zaÅ‚oÅ¼enia jednoczeÅ›nie? Czy nowe wymagania biznesowe nie powinny kaÅ¼dorazowo zmuszaÄ‡ programisty do modyfikacji wczeÅ›niej napisanych linijek kodu?

Okazuje siÄ™, Å¼e istniejÄ… techniki Å‚Ä…czÄ…ce te pozornie sprzeczne wymagania. Zobacz, jak technika _render props_ pozwala zaimplementowaÄ‡ rekomendacjÄ™ Open-Closed Principle:

Render props to jedna z wielu technik implementacji Open-Closed Principle w praktyce. Jak rozpoznaÄ‡, kiedy ta praktyka przyda siÄ™ w twoich projektach? Zawsze wtedy, kiedy w projekcie dana nowoÅ›Ä‡ lub rozszerzenie ma zaleÅ¼noÅ›Ä‡ czasowÄ…, rozwaÅ¼ zastosowanie tej zasady. PrzykÅ‚adowo:

- â€œDzisiaj dodajemy 5 filtrÃ³w do tabeli, ale w kolejnych kwartaÅ‚ach bÄ™dÄ… noweâ€
    
- â€œDzisiaj dodajemy 3 widgety, ale w przyszÅ‚oÅ›ci musi byÄ‡ ich wiÄ™cejâ€
    
- â€œDzisiaj na dashboardzie sÄ… 4 typy wykresÃ³w, ale chcemy wspieraÄ‡ 8â€
    

W kaÅ¼dym z tych scenariuszy element â€œOpenâ€ dotyczy pozostawania otwartym na nowoÅ›ci, a â€œClosedâ€ dotyczy spÃ³jnego mechanizmu, ktÃ³re zaimplementujesz na samym poczÄ…tku. ZamkniÄ™cie danej funkcjonalnoÅ›ci moÅ¼e chociaÅ¼by polegaÄ‡ na zdefiniowaniu jednego interfejsu, ktÃ³rego bÄ™dÄ… musiaÅ‚y siÄ™ trzymaÄ‡ wszystkie kolejne rozszerzenia:

```typescript
// Format danych w tabeli
interface TableRow {
  name: string;
  age: number;
  city: string;
}

// Generyczny interfejs do obsÅ‚ugi filtrowania danych
interface TableFilter<T extends TableRow> {
  apply(data: T[]): T[];
}

// Implementacja filtrowania po nazwie
class NameFilter implements TableFilter<TableRow> {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  apply(data: TableRow[]): TableRow[] {
    return data.filter((row) => row.name === this.name);
  }
}

// Implementacja filtrowania po wieku
class AgeFilter implements TableFilter<TableRow> {
  private age: number;

  constructor(age: number) {
    this.age = age;
  }

  apply(data: TableRow[]): TableRow[] {
    return data.filter((row) => row.age === this.age);
  }
}

// PrzykÅ‚adowe dane do tabeli
const data: TableRow[] = [
  {name: "Alice", age: 30, city: "New York"},
  {name: "Bob", age: 25, city: "San Francisco"},
  {name: "Alice", age: 29, city: "Los Angeles"},
];

// Open - zestaw filtrÃ³w jest otwarty na rozszerzenia i jest to zadanie niskiego ryzyka
const filters: TableFilter<TableRow>[] = [
  new NameFilter("Alice"),
  new AgeFilter(30),
];

// Closed - jednolita obsÅ‚uga filtrowania - warte przetestowania i zabezpieczenia
function applyFilters<T extends TableRow>(
  data: T[],
  filters: TableFilter<T>[]
): T[] {
  return filters.reduce(
    (filteredData, filter) => filter.apply(filteredData),
    data
  );
}

let filteredData = applyFilters(data, filters);
console.log(filteredData);
```

W obu przypadkach _TableFilter_ wprowadza reguÅ‚Ä™ - jeÅ›li chcesz wspieraÄ‡ nowy typ filtrowania danych, zaimplementuj klasÄ™ z funkcjÄ… â€œapplyâ€, ktÃ³ra przyjmie pewien zestaw danych i odpowiednio go ograniczy. Od strony konsumenta filtrÃ³w wiesz, Å¼e caÅ‚y wysiÅ‚ek sprowadzi siÄ™ wtedy do jednorazowej implementacji funkcji â€œapplyFiltersâ€, ktÃ³ra przetworzy bazowy zestaw danych i konfiguracjÄ™ filtrÃ³w. Takie podejÅ›cie pozwoli ci z Å‚atwoÅ›ciÄ… rozszerzaÄ‡ kod i udostÄ™pniaÄ‡ go innym osobom.

NajwaÅ¼niejszy element tej rekomendacji dotyczy okreÅ›lenia tego, jakie fragmenty interfejsu uÅ¼ytkownika, moduÅ‚u lub komponentu powinny byÄ‡ ukryte przed Å›wiatem zewnÄ™trznym, a jakie moÅ¼na konfigurowaÄ‡ w dowolny sposÃ³b. PiszÄ…c nasz kod w ten sposÃ³b minimalizujemy ryzyko wprowadzania bÅ‚Ä™dÃ³w przy jednoczesnym zachowaniu oczekiwanej elastycznoÅ›ci. Win-win!

**Inspiracje systemami Unix**

CUPID wspomina o rozwijaniu kodu zgodnie z tzw. filozofiÄ… Unixa (Unix Philosophy). W systemach UNIXowych promowane sÄ… maÅ‚e programy (awk, grep, tr, itd.), ktÃ³re przy pomocy operatora _pipe_ mogÄ… przekazywaÄ‡ sobie nawzajem dane i Å‚Ä…czyÄ‡ siÄ™ w realizacji wiÄ™kszego zadania:

```bash
echo "1 4 6 8 10" | 
  tr ' ' '\n' |                  # PodziaÅ‚ na wiele wierszy
  awk '{print $1*2}' |           # MnoÅ¼enie przez 2
  awk '$1<=10' |                 # Filtrowanie
  awk '{sum+=$1} END {print sum}' # Sumowanie
```

NaprawdÄ™ warto zastanowiÄ‡ siÄ™ przez chwilÄ™ jak eleganckie jest to rozwiÄ…zanie. NarzÄ™dzia majÄ… Å›ciÅ›le okreÅ›lonÄ… rolÄ™, muszÄ… byÄ‡ odpowiednio elastyczne i otwarte na rÃ³Å¼ne konteksty uÅ¼ycia, a wymiana lub ulepszenie jednego z nich nie zmusza nas do modyfikacji reszty (im mniej kodu musimy zmieniaÄ‡, tym mniejsza szansa na wprowadzenie potencjalnych bÅ‚Ä™dÃ³w).

Jak moÅ¼emy siÄ™ inspirowaÄ‡ Unix Philosophy na frontendzie? Zamiast imperatywnych poleceÅ„ opisywanych krok po kroku (wyraÅ¼enia warunkowe, pÄ™tle for, etc.), na frontendzie przyjÄ™tÄ…Â konwencjÄ… jest korzystanie z mikro-narzÄ™dzi i funkcji wyÅ¼szego rzÄ™du (_map, filter, reduce_), ktÃ³re moÅ¼emy ze sobÄ… Å‚Ä…czyÄ‡.

DziÄ™ki temu z kodu o takim ksztaÅ‚cieâ€¦

```javascript
const numbers = [1, 4, 6, 8, 10];
let sum = 0;

for (let i = 0; i < numbers.length; i++) {
    const doubled = numbers[i] * 2;
    if (doubled <= 10) {
        sum += doubled;
    }
}

console.log(sum);
```

â€¦moÅ¼emy przejÅ›Ä‡ na elegancki, deklaratywny Å‚aÅ„cuch moÅ¼liwych do Å‚Ä…czenia funkcji:

```javascript
const numbers = [1, 4, 6, 8, 10];

const result = numbers
  .map(num => num * 2)
  .filter(num => num <= 10)
  .reduce((sum, num) => sum + num, 0);

console.log(result);
```

PiszÄ…c kod w ten sposÃ³b, detale takie jak indeksy, warunki zatrzymania funkcji czy zmienne pomocnicze nie sÄ… nam potrzebne. Znowu - im mniejsza zÅ‚oÅ¼onoÅ›Ä‡ kodu, tym mniej okazji do popeÅ‚niania bÅ‚Ä™dÃ³w.

Nie zawsze uzyskamy w ten sposÃ³b kod bardziej wydajny (liczba wykonaÅ„ pÄ™tli siÄ™Â zwiÄ™ksza), ale czÄ™sto zdecydowanie Å‚atwiejszy w utrzymaniu.

KorzyÅ›ci wynikajÄ…ce ze stosowania praktyk takich jak SOLID czy CUPID docenia z biegiem czasu niemal kaÅ¼dy programista. ChociaÅ¼ nie sÄ… to zasady wymuszane przez Å›rodowisko programistyczne, a ich zÅ‚amanie nie grozi odebraniem licencji na programowanie, przyjmuje siÄ™ je za wskaÅºnik oprogramowania wysokiej jakoÅ›ci.

## Refaktoryzacja kodu zastanego

Wraz ze wzrostem doÅ›wiadczenia bÄ™dziesz poznawaÅ‚ kolejne wzorce i dobre praktyki, ktÃ³re pozytywnie wpÅ‚ywajÄ… na caÅ‚oÅ›ciowÄ… jakoÅ›Ä‡ projektu. W pewnym momencie moÅ¼e pojawiÄ‡ siÄ™ dylemat - czy wprowadzaÄ‡ je stopniowo, zaczynajÄ…c od najmniejszych moÅ¼liwych czÄ™Å›ci projektu, czy moÅ¼e postawiÄ‡ na duÅ¼y refaktoring (czyli proces podnoszenia jakoÅ›ci kodu w aplikacji), ktÃ³ry zacznie siÄ™ juÅ¼ na samej gÃ³rze drzewa komponentÃ³w?

Oba podejÅ›cia majÄ… swoje plusy i minusy, a szczegÃ³Å‚y poznasz poniÅ¼ej:

### **PodejÅ›cie â€œTop-downâ€**

Na caÅ‚oÅ›ciowe przepisanie aplikacji decydujemy siÄ™ zazwyczaj wtedy, kiedy sytuacja jest naprawdÄ™Â powaÅ¼na, lub kiedy chcemy wprowadziÄ‡ radykalne usprawnienia np. na poziomie stacku technologicznego (wymiana frameworka). W tym podejÅ›ciu nowa, ulepszona wersja aplikacji powstaje niezaleÅ¼nie od tej wdroÅ¼onej na produkcji. W momencie, kiedy funkcjonalnoÅ›ci sÄ… odwzorowane 1:1 moÅ¼na zadecydowaÄ‡ o zastÄ…pieniu poprzedniej wersji aplikacji tÄ… nowÄ…, z lepszÄ… architekturÄ… lub nowoczesnymi fundamentami.

**Plusy tego podejÅ›cia:**

- przestrzeÅ„ na wdroÅ¼enie istotnej zmiany architektury i stosu technologicznego
    
- kontynuacja pracy nad aktualnÄ… wersjÄ…Â aplikacji przebiega bez zakÅ‚Ã³ceÅ„
    
- czÄ™Å›Ä‡ zespoÅ‚u moÅ¼e skupiÄ‡ siÄ™ na nowym, niezaleÅ¼nym projekcie
    

**Minusy tego podejÅ›cia:**

- dÅ‚ugi czas trwania caÅ‚ego projektu, od jego rozpoczÄ™cia do wdroÅ¼enia na produkcjÄ™
    
- wymagane utrzymywanie dwÃ³ch spÃ³jnych wersji aplikacji - starej i nowej
    
- ryzyko zmiany planÃ³w i porzucenia projektu przed wdroÅ¼eniem na produkcjÄ™
    

### **PodejÅ›cie â€œBottom-upâ€**

W tym podejÅ›ciu core naszej aplikacji pozostaje stabilny, a my skupiamy siÄ™ na ulepszaniu najmniejszych moÅ¼liwych elementÃ³w aplikacji. W przypadku frontendu i interfejsÃ³w uÅ¼ytkownika, dobrze rozumianÄ…Â granicÄ… zmian jest poziom pojedynczego komponentu. OczywiÅ›cie nie musimy pozostaÄ‡ na jednym komponencie, ale moÅ¼emy tutaj zmieniaÄ‡ zestaw kilku wspÃ³Å‚pracujÄ…cych ze sobÄ… elementÃ³w.

**Plusy tego podejÅ›cia:**

- moÅ¼liwoÅ›Ä‡ ciÄ…gÅ‚ego i regularnego wdraÅ¼ania usprawnieÅ„ aplikacji na produkcjÄ™
    
- mniejsze ryzyko â€œrozjazduâ€ dwÃ³ch alternatywnych wersji aplikacji (por. podejÅ›cie top-down)
    
- Å‚atwiejszy model pracy dla mniejszych zespoÅ‚Ã³w o ograniczonych zasobach
    

**Minusy tego podejÅ›cia:**

- duÅ¼e bÅ‚Ä™dy na poziomie architektury mogÄ… byÄ‡ niemoÅ¼liwe do usuniÄ™cia
    
- skupiajÄ…c siÄ™ na lokalnych usprawnieniach moÅ¼emy straciÄ‡ z oczu caÅ‚oÅ›ciowy obraz projektu
    
- czas przeznaczany na zmiany lokalne moÅ¼e nie dawaÄ‡ odczuwalnych korzyÅ›ci dla uÅ¼ytkownika
    

### **KtÃ³re podejÅ›cie wybraÄ‡?**

ChociaÅ¼ oba podejÅ›cia majÄ… swoje plusy i minusy, to zgodnie ze zwinnymi praktykami rozwoju oprogramowania zdecydowanie Å‚atwiej realizowaÄ‡ refaktoryzacjÄ™ w podejÅ›ciu bottom-up. Pozwala ona na bardziej elastyczny model wdraÅ¼ania zmian, nie wymaga tak duÅ¼ego narzutu komunikacyjnego jak podejÅ›cie top-down i zmniejsza wymagany prÃ³g wejÅ›cia dla tych programistÃ³w, ktÃ³rzy chcÄ… w projekcie dodaÄ‡ coÅ› od siebie. Model komponentowy, ktÃ³ry jest obecnym standardem budowania frontendu, uÅ‚atwia wdraÅ¼anie zmian wÅ‚aÅ›nie w tym modelu, a komponenty wyznaczajÄ… granicÄ™ refaktoryzacji, nad ktÃ³rÄ… pracujemy.

Radykalne zmiany architektury, wymiana frameworka lub caÅ‚ych fundamentÃ³w aplikacji (tak jak w top-down) to zdecydowanie wiÄ™ksze ryzyko, trudniejsze dyskusje z przeÅ‚oÅ¼onymi i potencjalnie oddalajÄ…ca siÄ™ linia mety, ktÃ³rej czasami nigdy nie uda siÄ™ przekroczyÄ‡. WÅ‚aÅ›nie dlatego przepisywanie i wymiana caÅ‚ych aplikacji to najbardziej radykalny krok, ktÃ³rego wielu doÅ›wiadczonych programistÃ³w stara siÄ™Â zupeÅ‚nie unikaÄ‡.

## Podsumowanie

W naszym kursie podkreÅ›lamy, Å¼e opisywane tutaj praktyki to tylko i wyÅ‚Ä…cznie narzÄ™dzia, a nie cele twojej przygody z programowaniem. MoÅ¼na je traktowaÄ‡ jak obszerne notatki i podsumowania eksperymentÃ³w, ktÃ³re pozostawili po sobie bardziej doÅ›wiadczeni programiÅ›ci z przeszÅ‚oÅ›ci.

PoznajÄ…c i stosujÄ…c te najbardziej uÅ¼yteczne rekomendacje, oszczÄ™dzasz cenny czas i energiÄ™. Zamiast odkrywaÄ‡ koÅ‚o na nowo, moÅ¼esz w swoich projektach stosowaÄ‡ gotowe przepisy na rozwiÄ…zania problemÃ³w z ktÃ³rymi spotykano siÄ™ juÅ¼Â wielokrotnie.

Zanim zdecydujesz siÄ™ z nich zrezygnowaÄ‡, waÅ¼ne jest abyÅ› rozumiaÅ‚, dlaczego zostaÅ‚y one opracowane i jaka byÅ‚a oryginalna intencja autora. Ta wiedza pozwoli Ci dokonaÄ‡ przemyÅ›lanych wyborÃ³w na poziomie stacku technologicznego, projektowania architektury czy implementowania nowych wymagaÅ„ biznesowych.

W kolejnej lekcji poznasz zestaw najbardziej popularnych wzorcÃ³w projektowych, ktÃ³re na szerokÄ… skalÄ™ stosujÄ… autorzy najpopularniejszych bibliotek i frameworkÃ³w.