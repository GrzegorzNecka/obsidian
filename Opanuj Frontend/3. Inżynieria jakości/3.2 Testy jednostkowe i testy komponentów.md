## Testy jednostkowe

Testy jednostkowe to prawdziwy fundament piramidy testÃ³w. Praca w tym obszarze koncentruje siÄ™ na ==**weryfikacji najmniejszych, niepodzielnych czÄ™Å›ci kodu** ==(unitÃ³w - stÄ…d _testy jednostkowe_ lub _unit testy_), ktÃ³re ==Å›wiadomie izolujemy od caÅ‚ego kontekstu aplikacji==.

==Na poziomie unit testÃ³w najczÄ™Å›ciej bÄ™dziemy weryfikowaÄ‡ **pojedyncze funkcje**, **moduÅ‚y** i **komponenty**, ktÃ³rych dalsza integracja wpÅ‚ywa na caÅ‚Ä… aplikacjÄ™==.

W tej warstwie testÃ³w moÅ¼emy sprawdzaÄ‡ ==dziaÅ‚anie **logiki warunkowej** (zarÃ³wno na poziomie komponentÃ³w jak i serwisÃ³w), **efekty renderowania komponentu** (w zaleÅ¼noÅ›ci od stanu poczÄ…tkowego i akcji uÅ¼ytkownika), **zmiany stanu globalnego aplikacji** (gdzie symulujemy akcje i zdarzenia), czy **przepÅ‚yw danych na zamkniÄ™tym fragmencie aplikacji**==.

Aby poznaÄ‡ najwaÅ¼niejsze aspekty testowania jednostkowego, zobaczmy jak zweryfikowaÄ‡ dziaÅ‚anie funkcji opisanej w nastÄ™pujÄ…cy sposÃ³b:

> Funkcja sprawdza, czy imiÄ™ i nazwisko przekazane w formularzu sÄ… wypeÅ‚nione, a takÅ¼e sprawdza, czy wiek podany przez uÅ¼ytkownika nie ma wartoÅ›ci mniejszej od zera. 
> W przypadku bÅ‚Ä™dÃ³w zwraca listÄ™ komunikatÃ³w dotyczÄ…cych niepoprawnie wypeÅ‚nionych pÃ³l.

Oto implementacja takiej funkcji:

```typescript
// validator.ts
export function formValidator(firstName: string, lastName: string, age: number) {
    const errors: string[] = [];
    
    if (!firstName) {
        errors.push('First name is required');
    }
    
    if (!lastName) {
        errors.push('Last name is required');
    }
    
    if (age < 0) {
        errors.push('Age must be a positive number');
    }
    
    return errors;
}
```

Aby rozpoczÄ…Ä‡ pisanie testÃ³w, musimy najpierw okreÅ›liÄ‡ tzw. **scenariusze testowe**, czyli ==zestaw istotnych warunkÃ³w poczÄ…tkowych i oczekiwanych warunkÃ³w koÅ„cowych==. Åšwiadomie piszemy o warunkach i parametrach istotnych, bo w teorii do danej funkcji moÅ¼na przekazaÄ‡ co tylko chcemy, ale nasze testy nie mogÄ… rosnÄ…Ä‡ w nieskoÅ„czonoÅ›Ä‡. Skupiamy siÄ™ wiÄ™c na takim stanie aplikacji, ktÃ³ry moÅ¼e wystÄ…piÄ‡ w warunkach rzeczywistych.

JeÅ›li nie wiesz jak rozpoczÄ…Ä‡ pisanie scenariuszy, to moÅ¼esz zastosowaÄ‡ format **IF (this) THEN (that)**, co przykÅ‚adowo daje nastÄ™pujÄ…ce przepisy na testy:

- **JEÅšLI** firstName jest puste **TO** powinniÅ›my otrzymaÄ‡ odpowiedni bÅ‚Ä…d
    
- **JEÅšLI** lastName jest puste **TO** powinniÅ›my otrzymaÄ‡ odpowiedni bÅ‚Ä…d
    
- **JEÅšLI** age jest mniejsze od zera **TO** powinniÅ›my otrzymaÄ‡ odpowiedni bÅ‚Ä…d
    

ZauwaÅ¼, Å¼e juÅ¼ na tym etapie testy i scenariusze testowe dodajÄ… wartoÅ›Ä‡ do naszego projektu, bo dziÄ™ki nim otrzymujemy dokumentacjÄ™ oczekiwanego zachowania systemu. W firmowych bazach wiedzy (np. Confluence lub Notion) znajdziemy niekiedy tabelki lub artykuÅ‚y, ktÃ³re opisujÄ… aplikacjÄ™Â wÅ‚aÅ›nie na podstawie testÃ³w.

==PrzechodzÄ…c do poziomu samych testÃ³w, zwykle bÄ™dziemy tutaj stosowaÄ‡ strukturÄ™ â€œ**3xA**â€==:

- **Arrange** - Przygotuj Å›rodowisko i warunki poczÄ…tkowe testu
- **Act** - Wykonaj fragment logiki, ktÃ³rÄ… testujesz
- **Assert** - PrzeprowadÅº weryfikacjÄ™ stanu koÅ„cowego

StosujÄ…c ten format, nasz test podzieli siÄ™ na trzy nastÄ™pujÄ…ce po sobie etapy:

```typescript
test('...', () => {

  // Arrange - Przygotuj dane i obiekty (stan poczÄ…tkowy)
  const name = '';

  // Act - Wykonaj logikÄ™ aplikacji
  const errors = validate(name);

  // Assert - Zweryfikuj oczekiwania (stan koÅ„cowy)
  expect(errors).toHaveLength(1);

}
```

Wielu programistÃ³w decyduje siÄ™ na dodawanie komentarzy, ktÃ³re wskazujÄ… na poszczegÃ³lne etapy testu jednostkowego. Po czasie taka formalna struktura zamienia siÄ™ w nawyk, bywa teÅ¼ redukowana do dwÃ³ch etapÃ³w (np. arrange + act â†’ assert), a same komentarze stajÄ… siÄ™ opcjonalne.

Czy jesteÅ› w stanie odnaleÅºÄ‡ te trzy fazy - Arrange, Act i Assert - w testach poniÅ¼ej?

```typescript
// validator.test.ts
import { formValidator } from './validator';

describe('Form validation', () => {
    // Scenariusz 1
    
	
    test('should return an error if first name is missing', () => {    
		//Arrange
	const firstName = '';
        const lastName = 'Doe';
        const age = 30;
		//Act   
        const errors = formValidator(firstName, lastName, age);
        //Assert   
        expect(errors).toContain('First name is required');
    });

    // Scenariusz 2
    
   
    test('should return an error if last name is missing', () => {	   		    //Act                         //Arrange
        const errors = formValidator('John', '', 30);
         //Assert   
        expect(errors).toContain('Last name is required');
    });

    // Scenariusz 3
    test('should return an error if age is negative', () => {
       //Act                         //Arrange
        const errors = formValidator('John', 'Doe', -1);
        //Assert   
        expect(errors).toContain('Age must be a positive number');
    });
});
```

W pierwszym scenariuszu nasze â€œ3xAâ€ byÅ‚o zdefiniowane bardzo dosÅ‚ownie - mamy tutaj jawny etap przygotowania danych, mamy wykonanie logiki i na koÅ„cu sprawdzenie efektÃ³w naszej funkcji. W kolejnych scenariuszach widzimy poÅ‚Ä…czone fazy Arrange i Act, co czÄ™sto zdarza siÄ™ w przypadku pisaniu testÃ³w krÃ³tszych niÅ¼ kilka linijek.

Nasz **_test suite_** _(validator.test.ts)_**,** czyli moduÅ‚ grupujÄ…cy zestaw testÃ³w z tego samego obszaru, korzysta z kilku typowych funkcji pochodzÄ…cych z zewnÄ™trznego frameworka.

==Przy pomocy funkcji **describe** moÅ¼emy okreÅ›liÄ‡ zakres testowanej funkcjonalnoÅ›ci, a konkretne scenariusze weryfikujemy przy pomocy funkcji **test**. Funkcje takie jak **expect** czy **toContain** dostarczane sÄ… przez konkretne narzÄ™dzia do testowania, ktÃ³re omÃ³wimy w dalszej czÄ™Å›ci tej lekcji.

UruchamiajÄ…c takie testy w jednym z popularnych narzÄ™dzi uzyskujemy natychmiastowy feedback co do jakoÅ›ci stworzonego przez nas kodu:
![[Pasted image 20250321090307.png]]
Kiedy w przyszÅ‚oÅ›ci zmodyfikujemy fragment funkcji, wzglÄ™dem ktÃ³rej istniejÄ… wczeÅ›niej napisane testy, bÄ™dziemy tego Å›wiadomi natychmiast po ich uruchomieniu:
![[Pasted image 20250321090257.png]]
ZwrÃ³Ä‡ uwagÄ™, Å¼e pomimo dÄ…Å¼enia do kompletu zielonych testÃ³w, to wÅ‚aÅ›nie **te czerwone zarabiajÄ… na siebie najszybciej**. W koÅ„cu o problemach chcemy siÄ™ dowiadywaÄ‡ tak wczeÅ›nie, jak to moÅ¼liwe, a nie na skutek telefonu od klienta.

Z drugiej strony, jeÅ›li w twoim projekcie zauwaÅ¼asz dziesiÄ…tki wiecznie zielonych testÃ³w, ktÃ³rych nikt nigdy nie zepsuÅ‚, to warto przyjrzeÄ‡ im siÄ™ bliÅ¼ej. Czy na pewno testujesz wÅ‚aÅ›ciwe fragmenty kodu? Czy nie wpÅ‚ywajÄ… one negatywnie na czas budowania projektu? Czy twoje scenariusze nie sÄ… zbyt proste i odseparowane od rzeczywistych dziaÅ‚aÅ„ uÅ¼ytkownikÃ³w?

Nie ma jednoznacznej odpowiedzi, ale zostawiamy to spostrzeÅ¼enie dla ciekawskich.

### Kod testowalny

Bardziej doÅ›wiadczeni programiÅ›ci mogÄ… zwrÃ³ciÄ‡ uwagÄ™ na poprzedni przykÅ‚ad i stwierdziÄ‡, Å¼e w rzeczywistoÅ›ci rozwijanie testÃ³w jednostkowych jest zdecydowanie trudniejsze. SzczegÃ³lnie w kodzie zastanym, gdzie wielokrotnie zmieniaÅ‚y siÄ™ wymagania, standardy i osoby decyzyjne, pisanie testÃ³w moÅ¼e byÄ‡ utrudnione.

Zobaczmy na kolejny przykÅ‚ad, ktÃ³ry moÅ¼e to ilustrowaÄ‡. Mamy tutaj komponent, w ktÃ³rym Å›wiadomie Å‚amiemy dobre praktyki przedstawiane we wczeÅ›niejszych lekcjach:

```typescript
import { FormEvent, FormEventHandler, useState } from 'react';

function Form() {
  function formValidator(firstName: string, lastName: string, age: number) {
    const errors: string[] = [];

    if (!firstName) {
      errors.push('ImiÄ™ jest wymagane');
    }

    if (!lastName) {
      errors.push('Nazwisko jest wymagane');
    }

    if (!age || age < 0) {
      errors.push('Wiek musi byÄ‡ dodatni');
    }

    return errors;
  }

  const [firstName, setFirstName] = useState<string>('');
  const [lastName, setLastName] = useState<string>('');
  const [age, setAge] = useState<number>(0);
  const [errors, setErrors] = useState<string[]>([]);

  const handleSubmit: FormEventHandler<HTMLFormElement> = (
    event: FormEvent
  ) => {
    event.preventDefault();
    const results = formValidator(firstName, lastName, age);
    setErrors(results);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label className="flex flex-col max-w-[200px] my-2" htmlFor="first-name">
        <span className="text-white">ImiÄ™</span>{' '}
        <input
          id="first-name"
          name="first-name"
          type="text"
          value={firstName}
          onChange={(e) => setFirstName(e.target.value)}
        />
      </label>
      <label className="flex flex-col max-w-[200px] my-2" htmlFor="last-name">
        <span className="text-white">Nazwisko</span>{' '}
        <input
          id="last-name"
          name="last-name"
          type="text"
          value={lastName}
          onChange={(e) => setLastName(e.target.value)}
        />
      </label>
      <label className="flex flex-col max-w-[200px] my-2" htmlFor="age">
        <span className="text-white">Wiek</span>{' '}
        <input
          id="age"
          name="age"
          type="number"
          value={age}
          onChange={(e) => setAge(parseInt(e.target.value, 10))}
        />
      </label>

      <ul>
        {errors.map((error) => (
          <li className="text-red-400" key={error}>
            {error}
          </li>
        ))}
      </ul>

      <button
        type="submit"
        className="px-6 py-2 rounded-lg bg-blue-500 hover:bg-blue-300 mt-2"
      >
        Zapisz
      </button>
    </form>
  );
}

export default Form;
```

PatrzÄ…c na taki komponent moÅ¼na odnieÅ›Ä‡ mylne wraÅ¼enie, Å¼e testowanie jednostkowe na frontendzie jest trudniejsze, niÅ¼ w rzeczywistoÅ›ci. ==Rzeczywisty wpÅ‚yw na testowanie ma tutaj jednak sama struktura komponentu i zÅ‚amanie zasad, o ktÃ³rych mÃ³wiliÅ›my w pierwszym module (separacja warstw widoku i logiki, wydzielenie walidacji do osobnego moduÅ‚u)==.

JeÅ›li zdecydujesz siÄ™ przeprowadziÄ‡ refaktoryzacjÄ™ takiego komponentu wydzielajÄ…c niezaleÅ¼ne fragmenty logiki do osobnych moduÅ‚Ã³w, to odkryjesz kolejnÄ… wartoÅ›Ä‡ pisania testÃ³w. Ich efektem ubocznym jest podnoszenie jakoÅ›ci kodu, jego modularyzacja i wydzielanie jaÅ›niejszych granic odpowiedzialnoÅ›ci.

ZnajÄ…c podstawowe zaÅ‚oÅ¼enia dotyczÄ…ce testowania i generalnÄ… rekomendacjÄ™ dotyczÄ…cÄ… refaktoryzacji, zobacz teraz jak pisaÄ‡ pierwsze testy jednostkowe w twojej aplikacji.

### Pierwsze kroki

Aby zaczÄ…Ä‡ rozwijaÄ‡ testy jednostkowe w projekcie frontendowym, musimy zaczÄ…Ä‡ od rozszerzenia naszego projektu o dedykowane narzÄ™dzia. KiedyÅ› w tym celu stosowano dwa rodzaje bibliotek - tzw. test runnery, umoÅ¼liwiajÄ…ce uruchamianie testÃ³w i generowanie raportÃ³w (np. Karma), oraz biblioteki do budowania warunkÃ³w logicznych i tzw. asercji (np. Chai).

Obecnie odchodzi siÄ™ od takich podziaÅ‚Ã³w wykorzystujÄ…c biblioteki dostarczajÄ…ce caÅ‚oÅ›ciowe wsparcie dla testowania jednostkowego - na przykÅ‚ad [Vitest](https://vitest.dev/) oraz [Jest](https://jestjs.io/). Obie biblioteki dostarczajÄ… podobny zestaw funkcji uÅ‚atwiajÄ…cych testowanie, ale z powodu wsparcia dla ES Modules, TypeScripta i JSX, to **Vitest** bÄ™dzie naszÄ… kursowÄ…Â rekomendacjÄ….

[(ÅºrÃ³dÅ‚o)](https://vitest.dev/guide/features.html)

Zobacz jak rozwijaÄ‡ testy jednostkowe w oparciu o tÄ™ technologiÄ™:

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module2/lesson1/order-discount_**.

_Testy jednostkowe moÅ¼esz uruchomiÄ‡ poleceniem `npm test` w folderze_ **_examples_**_. Polecenie przyjmuje jako parametr wÅ‚aÅ›ciwy folder z testami, np. `npm test module2/lesson1/order-discount`._

### ZarzÄ…dzanie zaleÅ¼noÅ›ciami

PiszÄ…c testy jednostkowe szybko zauwaÅ¼ysz, Å¼e pozornie standardowy kod frontendowy moÅ¼e byÄ‡ peÅ‚en obiektÃ³w pochodzÄ…cych z rÃ³Å¼nych Å›wiatÃ³w i Å›rodowisk (np. kod logiki aplikacji, funkcje przeglÄ…darki, funkcje z zewnÄ™trznych bibliotek). Zawsze staraj siÄ™ precyzyjnie okreÅ›laÄ‡ co jest przedmiotem testu (tzw. ==**SUT - System Under Test**)==, a co z perspektywy testu moÅ¼na zignorowaÄ‡.

Te moÅ¼liwe do zignorowania zewnÄ™trzne zaleÅ¼noÅ›ci moÅ¼na w **Vitest** obsÅ‚uÅ¼yÄ‡ na co najmniej dwa sposoby:

- **spy** - pozwala Å›ledziÄ‡, czy i jak okreÅ›lona zaleÅ¼noÅ›Ä‡ zostaÅ‚a uÅ¼yta
- **mock -** pozwala zastÄ™powaÄ‡ konkretnÄ… zaleÅ¼noÅ›Ä‡ (np. funkcjÄ™) jego alternatywnÄ… wersjÄ…

Zobaczmy to na przykÅ‚adzie:

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module2/lesson1/mocks-spies_**.

W praktyce zdarza siÄ™, Å¼e bardziej zÅ‚oÅ¼one fragmenty kodu polegajÄ…ce na wielu zewnÄ™trznych zaleÅ¼noÅ›ciach naleÅ¼y najpierw uporzÄ…dkowaÄ‡, zanim przejdziemy do ich testowania. To jednak kolejny sygnaÅ‚ dla programisty, ktÃ³ry dziÄ™ki testowaniu moÅ¼e wprowadziÄ‡ swÃ³j projekt na wyÅ¼szy poziom.

### Åšrodowiska

DomyÅ›lnie uruchamiane testy w Vitest dziaÅ‚ajÄ… w Å›rodowisku node.js - oznacza to, Å¼e obiekty takie jak Window, Document czy LocalStorage nie bÄ™dÄ… dostÄ™pne z poziomu testÃ³w.

Aby umoÅ¼liwiÄ‡ ci testowanie jednostkowe z obiektami wbudowanymi bez potrzeby uruchamiania przeglÄ…darki, Vitest daje moÅ¼liwoÅ›Ä‡ konfigurowania Å›rodowisk do testÃ³w. To najbardziej popularne to **js-dom** - jego wykorzystanie i konfiguracjÄ™ zobaczysz poniÅ¼ej:

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module2/lesson1/jsdom-example_**.

## Testy komponentÃ³w

SzczegÃ³lnym rodzajem testÃ³w frontendowych, ktÃ³ry moÅ¼na zlokalizowaÄ‡ gdzieÅ› pomiÄ™dzy pierwszym i drugim szczeblem piramidy testÃ³w, sÄ… testy komponentÃ³w. MoÅ¼emy dziÄ™ki nim symulowaÄ‡ renderowanie fragmentÃ³w interfejsu uÅ¼ytkownika i weryfikowaÄ‡, co przy okreÅ›lonych parametrach zostanie zwrÃ³cone do przeglÄ…darki.

JednÄ… z najbardziej uniwersalnych bibliotek, ktÃ³ra uÅ‚atwia pisanie tego typu testÃ³w, jest [Testing Library](https://testing-library.com/) od [Kenta C. Doddsa](https://twitter.com/kentcdodds). DziÄ™ki adapterom dla popularnych frameworkÃ³w, Testing Library odpowie na potrzeby wiÄ™kszoÅ›ci nowoczesnych frontend developerÃ³w.

Aby zrozumieÄ‡ zaÅ‚oÅ¼enia tej biblioteki, przyjrzyjmy siÄ™ krÃ³tkiemu fragmentowi dokumentacji:

> You want to write maintainable tests for your Angular/Vue/React components. As a part of this goal, you want your tests to avoid including implementation details of your components and rather **focus on making your tests give you the confidence** for which they are intended.

==WÅ‚aÅ›nie dlatego dwa gÅ‚Ã³wne zaÅ‚oÅ¼enia Testing Library sÄ… nastepujÄ…ce==:

- ==**Praca na obiektach Document Object Modelu** (zamiast na abstrakcyjnych obiektach frameworkowych)==,
- ==**Praca na funkcjach symulujÄ…cych rzeczywiste akcje uÅ¼ytkownika** (a nie cykl Å¼ycia komponentÃ³w)==


PamiÄ™taj, Å¼e Testing Library nie jest test runnerem, wiÄ™c testy w oparciu o tÄ™ bibliotekÄ™ musimy uruchamiaÄ‡ we wspomnianym wczeÅ›niej Vitest lub Jest.

Zobaczmy, jak to wyglÄ…da w praktyce:

Aby skonfigurowaÄ‡ Testing Library w popularnych frameworkach, wejdÅº pod wybrany link:

- [Testing Library pod Angulara](https://testing-library.com/docs/angular-testing-library/intro)
- [Testing Library pod Vue](https://testing-library.com/docs/vue-testing-library/setup)
- [Testing Library pod Reacta](https://testing-library.com/docs/react-testing-library/setup/)
- [Testing Library pod Svelte](https://testing-library.com/docs/svelte-testing-library/setup)

WiÄ™cej na temat pobierania elementÃ³w na stronie - [zobacz ten link](https://testing-library.com/docs/queries/about/).

ğŸ“ Ten przykÅ‚ad znajdziesz w folderze **_examples/module2/lesson1/form-component_**.

## Druga strona medalu

Testy jednostkowe (i testy komponentÃ³w) sÄ… nieodzownym elementem procesu wytwarzania oprogramowania, oferujÄ…cym precyzyjne sprawdzanie poszczegÃ³lnych fragmentÃ³w kodu. Pomimo ich niezaprzeczalnych zalet, nie sÄ… teÅ¼ pozbawione wad, ktÃ³re mogÄ… wpÅ‚ynÄ…Ä‡ na ogÃ³lnÄ… jakoÅ›Ä‡ i niezawodnoÅ›Ä‡ aplikacji.

Testy jednostkowe **koncentrujÄ… siÄ™ na izolowanych fragmentach kodu** pomijajÄ…c to, w jaki sposÃ³b rÃ³Å¼ne czÄ™Å›ci aplikacji ze sobÄ… wspÃ³Å‚pracujÄ…. Taka izolacja moÅ¼e **nie ujawniÄ‡ problemÃ³w integracyjnych** czy zachowaÅ„ na styku komponentÃ³w. Testy jednostkowe mogÄ… czasami generowaÄ‡ **faÅ‚szywie negatywne wyniki** (_false negatives_) sugerujÄ…c, Å¼e kod jest poprawny, podczas gdy w rzeczywistoÅ›ci na poziomie interfejsu lub sprzecznych wymagaÅ„ uÅ¼ytkownik zmaga siÄ™ z problemami. MoÅ¼e to prowadziÄ‡ do faÅ‚szywego poczucia bezpieczeÅ„stwa z perspektywy autorÃ³w projektu.

Dodatkowo, **wiele niefunkcjonalnych wymagaÅ„** w aplikacji duÅ¼ej skali, takich jak wydajnoÅ›Ä‡ czy dostÄ™pnoÅ›Ä‡, wymaga od nas stosowania innego rodzaju testÃ³w. WÅ‚aÅ›nie dlatego w kolejnych lekcjach pÃ³jdziemy w gÃ³rÄ™ przedstawionej wczeÅ›niej piramidy, ale absolutnie nie zrezygnujemy z testowania jako takiego.

## ğŸ“š MateriaÅ‚y dodatkowe

PoniÅ¼sze materiaÅ‚y pozwolÄ… Ci pogÅ‚Ä™biÄ‡ wiedzÄ™ z tej lekcji:

1. [https://vitest.dev/guide/comparisons.html](https://vitest.dev/guide/comparisons.html)
2. [https://martinfowler.com/articles/2021-test-shapes.html](https://martinfowler.com/articles/2021-test-shapes.html)
