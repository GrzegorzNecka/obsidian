
### `codegen`

Codegen, GraphQL Codegen lub GraphQL Code Generator â€“ to kolejne fantastyczne narzÄ™dzie stworzone przez firmÄ™Â The GuildÂ [https://the-guild.dev/graphql/codegen](https://the-guild.dev/graphql/codegen). SÅ‚uÅ¼y ono do generowania rÃ³Å¼nego rodzaju kodu na podstawie schemy i zapytaÅ„ GraphQL. Codegen posiada dziesiÄ…tki wtyczek do rÃ³Å¼nych narzÄ™dzi, frameworkÃ³w i bibliotek, dziÄ™ki ktÃ³rym korzystanie z GraphQL staje siÄ™ nie tylko bajecznie proste, ale teÅ¼ po prostu przyjemne. Nie przeraÅº siÄ™Â jednak â€“ dziÄ™ki domyÅ›lnemuÂ `client-preset`Â nie bÄ™dziemy musieli instalowaÄ‡ niczego rÄ™cznie, a codegen zostanie skonfigurowany przez prostego wizarda. Zacznijmy wiÄ™c od dodania CLI:

```
pnpm add -D @graphql-codegen/cli

```

NastÄ™pnie pozostaje juÅ¼Â tylko wywoÅ‚anie:

```
pnpm graphql-code-generator init
```

i odpowiedÅºÂ na kilka prostych pytaÅ„:

- _What type of application are you building?_Â â€“Â React.
- _Where is your schema?_Â â€“ Podajemy URL schemy (moÅ¼esz wpisaÄ‡ tamÂ `https://graphql.hyperfunctor.com/graphql`).
- _Where are your operations and fragments?_Â â€“ Wciskamy [enter], pÃ³Åºniej zmodyfikujemy to ustawienie rÄ™cznie.
- _Where to write the output_Â â€“ RÃ³wnieÅ¼ [enter].
- _Do you want to generate an introspection file?_Â â€“ Nie, wiÄ™c wciskamy [enter].
- _How to name the config file?_Â â€“Â Zostawiamy domyÅ›lnÄ… nazwÄ™ ze wzglÄ™du na bug w codegenie [enter].
- _What script in package.json should run the codegen_Â â€“ [enter]

Po krÃ³tkiej chwili skrypt poinformuje nas jeszcze, Å¼e musimy teraz zainstalowaÄ‡ zaleÅ¼noÅ›ci, wiÄ™c odpalamyÂ `pnpm i`.

Teraz musimy jeszcze dokonaÄ‡ kilku zmian w utworzonej konfiguracji. Po pierwsze, zmieniamy nazwÄ™ pliku konfiguracyjnego zÂ `codegen.ts`Â naÂ `.graphqlrc.ts`. Jest to niezbÄ™dne do poprawnego dziaÅ‚ania wtyczki GraphQL w VS Code. Koniecznie musimy teÅ¼ zaktualizowaÄ‡ skryptÂ `codegen`Â wÂ `package.json`:

```
"codegen": "graphql-codegen --config .graphqlrc.ts"
```

Pozostaje juÅ¼Â tylko uruchomiÄ‡Â `pnpm codegen`Â i sprawdziÄ‡, czy dziaÅ‚a, a raczej nie dziaÅ‚a ğŸ™ƒ JeÅ›li wszystko do tej pory zrobiliÅ›my jak naleÅ¼y, to powinniÅ›my otrzymaÄ‡ komunikat z bÅ‚Ä™dem mÃ³wiÄ…cy nam, Å¼e nie mamy Å¼adnych queries GraphQL:

> Unable to find any GraphQL type definitions for the following pointers

Aby ten problem rozwiÄ…zaÄ‡, musimy doÂ `.graphqlrc.ts`Â dodaÄ‡ opcjÄ™Â `ignoreNoDocuments: true`. Teraz wszystko powinno byÄ‡ ok!

### `.graphqlrc.ts`

Przyjrzyjmy siÄ™Â po kolei opcjom, ktÃ³re zostaÅ‚y zawarte w domyÅ›lnej konfiguracji:

```ts

import type { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
	overwrite: true,
	ignoreNoDocuments: true,
	schema: "â€¦",
	documents: "src/**/*.tsx",
	generates: {
		"src/gql/": {
			preset: "client",
			plugins: [],
		},
	},
};

export default config;

```

- `overwrite`Â â€“ chcemy, aby codegen nadpisywaÅ‚ wygenerowane pliki gdy coÅ› siÄ™ zmieni.
- `schema`Â â€“ URL schemy; moÅ¼e to byÄ‡ teÅ¼ Å›cieÅ¼ka do pliku
- `documents`Â â€“ glob wskazujÄ…cy na pliki z kodem GraphQL
- `generates`Â â€“Â lista folderÃ³w, ktÃ³re ma wygenerowaÄ‡ codegen. Tutaj zdefiniowany jest tylko jedenÂ `src/gql/`
- `preset: client`Â â€“ zestaw najpopularniejszych wtyczek i ustawieÅ„

Pozmieniajmy tu nieco :) Na poczÄ…tek stwÃ³rzmy plik o nazwieÂ `.env`Â w gÅ‚Ã³wnym folderze repozytorium i dodajmy tam takÄ… linijkÄ™:

```
GRAPHQL_URL=https://â€¦

```

Gdzie zamiastÂ `https://â€¦`Â jest adres naszego API GraphQL. Znacznie uÅ‚atwi nam to pracÄ™, bo bÄ™dziemy mieli tylko jedno miejsce, w ktÃ³rym bÄ™dzie przechowywaÄ‡ adres API. I co istotne, bÄ™dziemy mogli tÄ™ wartoÅ›Ä‡ prosto zmieniaÄ‡ w zaleÅ¼noÅ›ci od Å›rodowiska (lokalnie,Â _preview_,Â _production_).

Teraz odwoÅ‚amy siÄ™ do tej zmiennej w konfiguracji GraphQL dziÄ™ki uÅ¼yciu paczkiÂ `@next/env`. Next.js uÅ¼ywa jej wewnÄ™trznie i jeÅ›li my rÃ³wnieÅ¼ z niej skorzystamy, to bÄ™dziemy mieÄ‡ pewnoÅ›Ä‡, Å¼e plikiÂ `.envâ€¦`Â Å‚adujemy w taki sam sposÃ³b, jak robi to sam Next â€“Â [wcale nie jest to takie proste (link do docsÃ³w)](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables#environment-variable-load-order). Instalujemy paczkÄ™, importujemy z niejÂ `loadEnvConfig`Â i wywoÅ‚ujemy podajÄ…c Å›cieÅ¼kÄ™ do aktualnego katalogu (_Current Working Directory_):

```ts
pnpm add -D @next/env

```

```diff
+import { loadEnvConfig } from "@next/env";
 import type { CodegenConfig } from "@graphql-codegen/cli";

+loadEnvConfig(process.cwd());
+
 const config: CodegenConfig = {
-       schema: "https://â€¦",
+       schema: process.env.GRAPHQL_URL,

```

Teraz zmieÅ„my opcjÄ™Â `documents`. Nie bÄ™dziemy trzymaÄ‡ kodu GraphQL w plikach TS. ChoÄ‡ jest to caÅ‚kowicie poprawne i czasem wygodne, to jednak decydujemy siÄ™Â tu na jasny podziaÅ‚: pliki z rozszerzeniemÂ `.graphql`Â w folderzeÂ `graphql`:

```diff
-       documents: "src/**/*.tsx",
+       documents: "src/graphql/*.graphql",

```

Pozostaje nam jeszcze przeÅ‚Ä…czyÄ‡Â kilka opcji pochodzÄ…cych z samegoÂ `client-preset`Â (tutaj znajdziesz opis wszystkich:Â [https://the-guild.dev/graphql/codegen/plugins/presets/preset-client](https://the-guild.dev/graphql/codegen/plugins/presets/preset-client)).

Po pierwsze, wyÅ‚Ä…czymy na razie caÅ‚kowicieÂ _fragment masking_. Trudno nam znaleÅºÄ‡ dobre zastosowanie dla tej opcji, ktÃ³ra niestety domyÅ›lnie jest wÅ‚Ä…czona. Ponadto dodajemy teÅ¼ kilka opcji poprawiajÄ…cych bezpieczeÅ„stwo i wygodÄ™. Za moment je wszystkie omÃ³wimy:

```diff
                        preset: "client",
-                       plugins: [],
+                       presetConfig: {
+                               fragmentMasking: false,
+                       },
+                       config: {
+                               useTypeImports: true,
+                               enumsAsTypes: true,
+                               defaultScalarType: "unknown",
+                               skipTypename: true,
+                               documentMode: "string",
+                       },


```

- `useTypeImports`Â â€“ preferujemyÂ `import type`, gdy importowane sÄ… wyÅ‚Ä…cznie typy.
- `enumsAsTypes`Â â€“ chcemy, aby GraphQLowe enumy byÅ‚y zamieniane na unie stringÃ³w (typ) zamiastÂ `enum`Â w TypeScripcie.
- `defaultScalarType`Â â€“ domyÅ›lnie nieznane skalary sÄ… reprezentowane przezÂ `any`; to bardzo Åºle.
- `skipTypename`Â â€“ specjalne poleÂ `__typename`Â pojawi siÄ™Â w typach tylko tam gdzieÂ _explicite_Â o nie poprosimy.
- `documentMode`Â â€“ chcemy, aby zapytania byÅ‚y zapisywane jako stringi, a nie automatycznie zamieniane naÂ [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree).

Opcji jest oczywiÅ›cie wiÄ™cej, ale uznaliÅ›my, Å¼e te sÄ… najwaÅ¼niejsze. Ostatecznie caÅ‚y plikÂ `.graphqlrc.ts`Â wyglÄ…da u nas tak:

```ts
import { loadEnvConfig } from "@next/env";
import type { CodegenConfig } from "@graphql-codegen/cli";

loadEnvConfig(process.cwd());

const config: CodegenConfig = {
	schema: process.env.GRAPHQL_URL,
	overwrite: true,
	ignoreNoDocuments: true,
	documents: "src/graphql/*.graphql",
	generates: {
		"src/gql/": {
			preset: "client",
			presetConfig: {
				fragmentMasking: false,
			},
			config: {
				useTypeImports: true,
				enumsAsTypes: true,
				defaultScalarType: "unknown",
				skipTypename: true,
				documentMode: "string",
			},
		},
	},
};

// eslint-disable-next-line import/no-default-export
export default config;


```

Uff, to niezÅ‚a przeprawa tylko po to, aby skonfigurowaÄ‡ coÅ› co jeszcze nic nie robi, prawda? ğŸ˜‰ Ale, jak to siÄ™ mÃ³wi,Â _jak sobie poÅ›cielesz, tak siÄ™Â wyÅ›pisz_!

## Pobieranie danych z GraphQL

### QueryÂ `ProductsGetList`

Napiszmy teraz query w celu pobrania listy produktÃ³w z naszego API GraphQL. Z Playgroundem to naprawdÄ™ proste:

```graphql

query ProductsGetList {
	products(first: 10) {
		id
		name
		description
		categories(first: 1) {
			name
		}
		images(first: 1) {
			url
		}
		price
	}
}


```

âš ï¸Â **Uwaga**: ZwrÃ³Ä‡ uwagÄ™ na konwencjÄ™ nazw, ktÃ³rÄ… tutaj zastosowaliÅ›my â€“ najpierw nazwa encji, potem operacja:Â `ProductsGetList`, a nieÂ `GetProductsList`. DziÄ™ki takiemu nazewnictwu Query bÄ™dÄ… logicznie uÅ‚oÅ¼one na liÅ›cie i w dokumentacji. Jest to popularne rozwiÄ…zanie z uwagi na brak namespace'Ã³w w GraphQL.

Tak napisane query zapisz w plikuÂ `src/graphql/ProductsGetList.graphql`, a nastÄ™pnie uruchomÂ `pnpm codegen`. Przejrzyj to, co pojawiÅ‚o siÄ™ w folderzeÂ `src/gql`, ale nas najbardziej interesuje plikÂ `src/gql/graphql.ts`. Jest on bardzo dÅ‚ugi bo zawiera wszystkie typy, obiekty, query, mutation i inne rzeczy pochodzÄ…ce z endpointu GraphQL. GdzieÅ› na koÅ„cu tego pliku znajdziesz nawiÄ…zania do query, ktÃ³re napisaliÅ›my: typyÂ `ProductsGetListQueryVariables`Â iÂ `ProductsGetListQuery`Â orazÂ `ProductsGetListDocument`. Codegen automatycznie wygenerowaÅ‚ dla nas odpowiednio typ parametrÃ³w query i typ wyniku query, a takÅ¼e interesujÄ…cÄ… nas instancjÄ™Â klasyÂ `TypedDocumentString`, ktÃ³ra spina ze sobÄ… wszystkie te rzeczy. To wÅ‚aÅ›nie zÂ `â€¦Document`Â bÄ™dziemy gÅ‚Ã³wnie korzystaÄ‡.

â„¹ï¸Â **Notka**: MoÅ¼esz uruchomiÄ‡Â `pnpm codegen --watch`Â aby stale nasÅ‚uchiwaÄ‡ na zmiany i automatycznie kompilowaÄ‡ pliki w tle.

âš ï¸Â **Uwaga**: JeÅ›li widzisz jakiÅ› bÅ‚Ä…d importÃ³w na poczÄ…tku plikuÂ `src/gql/graphql.ts`Â to musisz rÄ™cznie dodaÄ‡ paczkÄ™ brakujÄ…cÄ… paczkÄ™:Â `pnpm add -D @graphql-typed-document-node/core`











